 

#  北游国际面试题总结

>人事部分
>
>html、css
>
>javascript
>
>网络请求

# 一、人事部分

- 参考网址

  https://juejin.cn/post/7010948744560508941

- 自我介绍

  **模板一:**

  你好，我叫XXX,有XX年工作经验，来应聘前端开发工程师这一岗位。我之前在XXX工作过，期间主要负责前端项目、app和微信小程序的开发和维护工作。参与开发的项目有XX个，独自开发的项目的有XX个。在此期间，商城/交友/工具/直播/类项目做的比较多。其中印象最深的是XX项目，因为是第一个独立开发的项目/学到知识最多的项目/最难的项目/最近才做好的项目/开发周期最长的项目。我在招聘网上看到咱们公司的招聘信息，感觉自身跟公司比较契合，希望能够加入公司，成为公司的一员。

  **模板二:**

  

  **注意：语速不能过慢不能过快，不要边想边说，一定是把自我介绍想好，一般人的语速是在80-160之间**
  
- 公司有几个人，部门构成是什么，你所属哪个部门，有几个人

  甲方 掏钱  18000
    --IT劳务外派公司 15000 - 3000
  乙方  --  外包公司
    12个人
    人事部 1
    财务部 1
    技术部 7 1个 UI1个 后端2（后端的某一个人员）  前端2  1个ios/ 1android
    市场部 4 2个  4个项目 * 2-8w = 20w
           15% * 50 = 7.5w
           UI 5k+14k+14K + 8k = 4.1
           
    政府 -- 人脉 

    产品经理、UI、后端、前端、CTO（技术总监）
    根据客户需求 ->  墨刀 -> 原型图
    UI  : 设计图、切。。。
    后端: java、PHP、Python、Ruby、Golang
    前端: 页面 

- .为什么离职


![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cde680055554c689d970df11b969dc9~tplv-k3u1fbpfcp-watermark.awebp)

# 二、html部分

## 2.1  HTMl5新增特性有哪些？

(1) 新增了语义化标签

(2) 新增了音频（audio）视频（video）标签

(3) 新增了canvas和svg绘图

(4) 新增了地理定位（navigator.geolocation）

(5) 新增了拖拽API (drapable)

(6) 新增了多线程技术web worker 

(7) 新增了即时通讯web socket

## 2.2 CSS3 新增特性

(1) 增加了transition渐变animation动画

(2) 选择器、阴影、弹性布局flex

(3) 媒体查询等

## 2.3 W3C标准有哪些？（可以不会）

(1) 标准分为三个层面，结构(html)、行为(js)、表现(css)

(2) 标准有:

(3) 文档类型需要声明（DOCTYPE）

(4) 编码格式需要声明 <meta charset=”utf-8”>

(5) javascript代码需要定义

(6) <script language=”javascript” type = ”text/javascript”></script>

(7) css代码需要定义

(8) <style type=”text/css”></style>

(9) 标签名字和标签内部属性名字小写等

## 1. 什么是回流（reflow）什么是重绘(repaint)？

改变了样式，改变了背景色，color之类的就会进行重绘，回流是指改变了宽高，增删了元素，就会进行回流

## 2.4 你遇到哪些浏览器兼容问题？您怎么处理浏览器兼容性问题的 ？？？？？？？？
参考地址: https://www.cnblogs.com/wxf-h/p/10513342.html
- **css兼容性问题**

  1. cursor:hand VS cursor:pointer
  ```
  firefox 不支持hand，但ie支持 pointer
  解决方法:统一使用pointer
  ```
  2. innerText在IE中能正常工作，但在FireFox中却不行
  3. CSS透明
  4. 盒子模型
  5. 块属性标签float后，又有横行的margin情况下，在IE6显示margin比设置的大
  6. 图片默认有间距
  7. 万能清除浮动
  8. IE捉迷藏的问题
  9. 溢出显示省略号
  10. IE6下图片下有空隙产生
  11. 超链接访问过后hover样式就不出现的问题
- **JS里面的兼容性问题**
  1.const问题
      说明:Firefox下,可以使用const关键字或var关键字来定义常量;IE下,只能使用var关键字来定义常量. 
	
  ​	**解决方法：统一使用var关键字来定义常量.**
	2.event.srcElement问题
  ​    说明：IE下，event对象有srcElement属性，但是没有target属性；Firefox下，even对象有target属性，但是没有srcElement属性。
  ​    **解决方法：使用srcObj =event.srcElement ?event.srcElement : event.target;**
  3.事件绑定
     IE：dom.attachEvent();
     其他浏览器：dom.addEventListener();
     标准浏览器采用事件捕获的方式对应IE的事件冒泡机制（即标准由最外元素至最内元素或者IE由最内元素到  	最外元素）最后标准方亦觉得IE这方面的比较合理，所以便将事件冒泡纳入了标准，这也addEventListener第三个参数的由来，而且事件冒泡作为了默认值。
  
  4. 略有不同
  	IE:ActiveXObject
      其他：xmlHttpReuest
## 2.5 CSS伪类选择器有哪些?（会一点就行了）

(1) :before 		在...之前 

(2) :after  	在...之后

(3) :active  	点击

(4) :hover  	鼠标悬停

(5) :first-letter  所有文字当中的第一个

(6) :first-line  	所选元素当中的第一行

(7) :first-child  第一个子元素

(8) :nth-child()  获取子元素

(9) :nth-of-type  获取指定类型的子元素

等等几十个

## 2.6 常用的适配手段有哪些

1.媒体查询

2.弹性布局

3.使用各种UI框架，UI框架一般都做了适配工作

4.手淘适配方案 （使用flexiable插件完成适配）

## 2.7 说说你对flex布局的理解
参考: https://www.cnblogs.com/jpwz/p/12483053.html
Flex 是 Flexible Box 的缩写，意为"灵活的盒子"或"弹性的盒子"，所以 flex 布局一般也叫作"弹性布局"。

 - display 属性
 - flex-direction 属性
 - flex-wrap 属性
 - flex-flow
 - justify-content 属性
 - align-items 属性
 - align-content 属性
## 2.8 rem和em、VH、VW、PX的区别
em是相对于父级标签的字体大小来定义的
rem是相对于html标签的字体大小来定义的

**vh and vw：**相对于视口的高度和宽度，而不是父元素的（CSS百分比是相对于包含它的最近的父元素的高度和宽度）。



## 2.9 canvas和svg的区别
都可以用来绘制图形，但是canvas是基于js来绘制的，svg是基于xml来绘制的.SVG绘制出来的是矢量图。
## 2.10什么是BFC？BFC的布局规则是什么？如何创建BFC？BFC应用？######################
`BFC` 是 `Block Formatting Context `的缩写，即块格式化上下文。`BFC`是CSS布局的一个概念，是一个环境，里面的元素不会影响外面的元素。 布局规则：Box是CSS布局的对象和基本单位，页面是由若干个Box组成的。元素的类型和display属性，决定了这个Box的类型。不同类型的Box会参与不同的`Formatting Context`。 

创建：浮动元素 `display：inline-block position:absolute` 

应用: 1.分属于不同的`BFC`时,可以防止`margin`重叠 2.清除内部浮动 3.自适应多栏布局

## 2.11 BFC的作用
(1)避免margin重叠
(2)清除浮动

## 2.12 清除浮动的方式有哪些
(1)浮动元素后新增标签，并且设置属性clear:both ;
(2)浮动元素的父标签设置属性overflow:hidden;
(3)设置伪类选择器 XX:after{clear:both}

## 2.13 网站页面常见优化的手段
(1)优化图片资源的格式（优先级选择webp > jpeg > png > bmp）
(2)使用压缩文件 min.js、min.css
(3)使用浏览器缓存（cookie ， localStorage）
(4)尽量减少请求次数
(5)使用懒加载，避免一次性请求过多

## 2.14 常见的浏览器内核有哪些？？？？？？

![image-20210923120048016](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210923120048016.png)

![3842C6DC6B349E0218BBEDF7DDE17AB5](/Users/a8613165982052/Library/Containers/com.tencent.qq/Data/Library/Caches/Images/3842C6DC6B349E0218BBEDF7DDE17AB5.png)



## 2.15 CSS选择器优先级

- 内联样式表的权值为 1000

- ID 选择器的权值为 100

- Class 类选择器的权值为 10

- HTML 标签选择器的权值为 1

  通过使用加法计算出来权重的大小

## 2.16 左右两边固定宽度 （左边固定右边自适应布局）中间自适应  布局实现

圣杯布局、双飞翼布局

左边固定右边自适应 七种方式

https://segmentfault.com/a/11900000106986091

1.width: calc(100% - 140px)

2.双folat

## 2.17 九宫格实现方式

- flex布局 （css3）
- grid布局 （css3新增）
- float
- table       （）

参考地址：https://www.cnblogs.com/sunshq/p/10118425.html

## 2.18 让一个盒子在父元素的中进行左右垂直居中

参考地址： https://www.cnblogs.com/yingtoumao/p/11541256.html



## 2.19 什么是盒子模型？

w3c标准盒模型：width+左右内边距+左右边框+左右外边距
怪异盒模型：width+左右外边距

Centent-box:标准盒模型
Border-box：怪异盒模型

## 2.20 简述字体图标的原理，动手实现使用 iconfont 实现字体图标的 demo。 

```css
/* 定义font-family */
@font-face {  //@font-face自定义一个字体模块
    font-family: "myiconfont";      //定义字体的名称
    //字体的格式，主要用于浏览器识别，一般有以下几种——truetype,opentype,truetype-aat,embedded-opentype,avg
    src: url('./iconfont.woff2') format('woff2'), 
         url('./iconfont.woff') format('woff'),
         url('./iconfont.ttf') format('truetype');
}

/*  */
//定义总体的图标的样式
[class^="iconfont"],
[class*=" iconfont"] {
    font-family: "myiconfont";
    font-style: normal;
    font-size: 14px;
}
//定义单个图标
.icon-star::before {
    content: "\e616";
}

```

## 2.21 浏览器渲染机制、重绘、重排###

网页生成过程：

- `HTML`被HTML解析器解析成`DOM` 树
- `css`则被css解析器解析成`CSSOM `树
- 结合`DOM`树和`CSSOM`树，生成一棵渲染树(`Render Tree`)
- 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成
-  

**重排(也称回流):** 当`DOM`的变化影响了元素的几何信息(`DOM`对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 触发：

1. 添加或者删除可见的DOM元素
2. 元素尺寸改变——边距、填充、边框、宽度和高度

**重绘：** 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 触发：

- 改变元素的`color、background、box-shadow`等属性

**重排优化建议：**

1. 分离读写操作
2. 样式集中修改
3. 缓存需要修改的`DOM`元素
4. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
5. 动画开始`GPU`加速，`translate`使用`3D`变化

`transform` 不重绘，不回流 是因为`transform`属于合成属性，对合成属性进行`transition/animate`动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。

## 2.22 css 怎么开启硬件加速(GPU 加速)

浏览器在处理下面的 css 的时候，会使用 GPU 渲染

- transform（当 3D 变换的样式出现时会使用 GPU 加速）
- opacity
- filter
- will-change

```javascript
采用 transform: translateZ(0)
采用 transform: translate3d(0, 0, 0)
使用 CSS 的 will-change属性。 will-change 可以设置为opacity、transform、top、left、bottom、right。
```

> 注意！层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。

# 三、Javascript部分

## 3.1 js数据类型有哪些

Number 、String、Boolean、Null、Undefined、Object、Symbol、BigInt

## 3.2 怎么判断对象还是数组？

   **最少3种以上**

- instanceof 返回t/f

- **对象的constructor属性** 

  constructor可以当做prototype的属性，
  a.constructor = a.**proto**.constructor = A.prototype.constructor =A

- **Object.prototype.toString.call(arr)**

- **Array.isArray()** 

## 3.3 new关键字做了什么  this指向############################

- 创建一个简单空对象

- 原型的执行，确定对象o的原型链

- 绑定this对象为o，传入参数；执行Person构造函数，进行属性和方法的赋值操作

- 返回结果

  

  # 普通函数this指向

  函数的this指向遵循一个基本原则：谁调用的函数，函数的this就指向谁，否则指向全局

  # 箭头函数this指向

  首先我们要知道，箭头函数本身是没有 this，箭头函数 this 是定义箭头函数时父级作用域的 this，也就是说使用箭头函数时，箭头函数内部的 this，我们只需要看定义该箭头函数时，该箭头函数父级的 this 即可
  
  构造函数指向new出来的新对象
  
  

## 3.4  Javascript事件流

DOM事件流是有两种的，一种是捕获型事件流，另外一种是冒泡型事件流，两者其实都很好理解，下面我们就来详细介绍一下，为了大家更好的理解，我们就先介绍下冒泡型事件流

1. 冒泡型事件流 **"冒泡"**：没错就是你心中想的，冒泡就是我们平时可以常见的，例如水中的气泡往上冒，这就是冒泡，所以冒泡型事件流，就是当你点击目标元素的时候，当前所触发的一些事件会向父元素中传递，这就是所谓的事件冒泡,如果大家还是有不理解的地方，可以直接看后面的代码
2. 捕获型事件流 捕获型事件流正好是与冒泡型事件流相反的，当你点击目标元素的时候，在该目标元素上点击触发的事件，会从父元素向下传递
3. 其实，DOM标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件捕获阶段：实际目标在捕获阶段不会接收事件。也就是在捕获阶段，事件从document到再到就停止了。 处于目标阶段：事件在上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。

## 3.5 怎么阻止冒泡事件

w3c:  event.stopPropagation()

IE:     window.event.cancelBubble = true

## 3.6 怎么阻止默认事件

event.preventDefault()

## 3.7 什么是事件委托

用事件冒泡的原理，自己所触发的事件， 让他的父元素代替执行。

## 3.8 什么是抖动 节流

参考:

https://blog.csdn.net/Welkin_qing/article/details/88126044

- 函数防抖。典型的案例就是窗口大小的变化、模糊查询

  **规定函数至少间隔多久执行**

- 函数节流 典型的案例就是鼠标不断点击触发，规定在n秒内多次点击只有一次生效、用户登录。

  **规定函数在某时间段内最多执行一次**

函数防抖和函数节流的对比
不管是函数节流还是函数防抖，减少的都是事件处理程序的调用频率，而不是时间的调用频率

何时使用函数防抖，何时使用函数节流？
当我们只需要处理最后一次触发事件时，用函数防抖。（例如：窗口大小变化，并不需要计算中间变化的过程，只需要窗口大小改变完成后的值）
当事件触发过于频繁，我们需要限制事件处理程序的调用频率时，用函数节流

## 3.9 什么是深浅拷贝怎么实现

浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用. 不拷贝地址，两者属性值指向同一内存空间。简单来讲，就是改变其中一个对象，另一个对象也会跟着改变。

拷贝对象各个层级的属性。简单的讲，就是复制出来的每个对象都有属于自己的内存空间，不会互相干扰。



实现: 最少2种 -- 深度拷贝

```javascript
// 深拷贝：对对象内部进行深拷贝，支持 Array、Date、RegExp、DOM
const deepCopy = (sourceObj) => {
  // 如果不是对象则退出（可停止递归）
  if(typeof sourceObj !== 'object') return;
  
  // 深拷贝初始值：对象/数组
  let newObj = (sourceObj instanceof Array) ? [] : {};

  // 使用 for-in 循环对象属性（包括原型链上的属性）
  for (let key in sourceObj) { 
    // 只访问对象自身属性
    if (sourceObj.hasOwnProperty(key)) {
      // 当前属性还未存在于新对象中时
      if(!(key in newObj)){
        if (sourceObj[key] instanceof Date) {
          // 判断日期类型
          newObj[key] = new Date(sourceObj[key].getTime());
        } else if (sourceObj[key] instanceof RegExp) {
          // 判断正则类型
          newObj[key] = new RegExp(sourceObj[key]);
        } else if ((typeof sourceObj[key] === 'object') && sourceObj[key].nodeType === 1 ) {
          // 判断 DOM 元素节点
          let domEle = document.getElementsByTagName(sourceObj[key].nodeName)[0];
          newObj[key] = domEle.cloneNode(true);
        } else {
          // 当元素属于对象（排除 Date、RegExp、DOM）类型时递归拷贝
          newObj[key] = (typeof sourceObj[key] === 'object') ? deepCopy(sourceObj[key]) : sourceObj[key];
        }
      }
    }
  }
  
  
  return newObj;
}

// deepCopy 函数测试效果
const objA = {
  name: 'jack',
  birthday: new Date(),
  pattern: /jack/g,
  body: document.body,
  others: [123,'coding', new Date(), /abc/gim,]
};

const objB = deepCopy(objA);
console.log(objA === objB); // false
console.log(objA.others === objB.others); // false
console.log(objA, objB); // 对象内容一样
```

## 3.20 call、bind和apply的区别

1.  都可以更改this指向

2. call，bind后面的第一个参数是指向的对象，第二个参数是往对象传的值

3. apply后面的第一个参数是指向的对象，第二个参数是数组，数组里面是往对象传的值（arguments  全部参数）

4. call和apply更改this指向会自动调用， bind需要手动调用返回的是一个函数

## 3.21 cookie，sessionStorage和localStorage的区别是什么

1. 都可以用来存储数据

2. cookie一条数据大小不能超过4KB ，最多不能存储超过20条，如果没有设置过期时间，那么在浏览器关闭后消失

3. sessionStorage是会话存储，一条大小不能超过5M，数量没有限制，关掉页面数据消失

4. localStorage本地存储，一条大小不超过5M，数量没有限制，除非主动删除，否则数据不会消失

## 3.22  什么是原型链  prototype原型 作用域

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的__proto__隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的__proto__中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链
![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20200324172235599.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMzODU4NA%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634980485&t=0701089532bb49fd02da93167363a8db)

### 作用域链

当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain,不简称sc）来保证对执行环境**有权**访问的变量和函数的***\*有序\****访问。作用域第一个对象始终是当前执行代码所在环境的变量对象（VO）

## 3.23 什么是闭包？闭包的作用场景是什么？

闭包指的是一个函数可以访问另一个函数作用域中变量

各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，**闭包就是能够读取其他函数内部变量的函数**。

由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把**闭包简单理解成"定义在一个函数内部的函数"**。

所以，在本质上，**闭包就是将函数内部和函数外部连接起来的一座桥梁。**

- 采用函数引用方式的setTimeout调用

- 小范围代替全局变量

- 访问私有变量的特权方法

- 模块化

  使用作用域链的形式说明闭包是什么？

  当外层函数执行时，内层函数进行定义，此时内层函数生成作用域链，作用域链中包含外层函数的AO对象，导致AO无法释放，这就形成了闭包。
  
  

**闭包缺点：**会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

## 3.24 同步异步的区别是什么

***\*同步：上一个任务没有执行完，下一个任务不能开启\****

***\*异步：即便上一个任务没有执行完，下一个任务仍然可以开启\****

## 3.25 Javascript中异步操作 及其js中EventLoop 事件循环

**(1)** ***\*setTimeout 延时器\****

**(2)** ***\*setInterval 计时器\****

**(3)** ***\*数据请求\****

EventLoop ： 暂定

## 3.26 es6有哪些新特性

​	1.let关键字，声明变量

​	2.const关键字，声明常量

​	3.模板字符串

​	4.箭头函数

​	5.对象和数组解构

​	6.Map、Set集合

​	7.Promise对象

​	8.引入class关键字

​    9.ES6模块化

## 3.27 var 和let、Const的区别是什么

(1) let声明的变量只能先声明后赋值

(2) 只能使用let对同一个变量声明一次

(3) let声明的变量有块级作用域

 var 和let定义变量  const常量

1. let、const声明的变量仅在块级作用域内有效，var 声明变量是全局的，没有块级作用域功能
2. let 、const 不存在变量提升，在声明前使用会报错：Uncaught ReferenceError, var 存在变量在var声明之前就访问对应的变量，则会得到undefined。
3. let 、const不能在同一块级作用域内重复申请**var** **可以重复声明**

## 3.28 数组的常用方法有哪些？

pop、push、cancat、shift、unshift、join、filter、map、some、everything、replace、find、splice、

push('元素') 追加在最后 返回数组的长度。

unshift('元素') 添加在最前 返回数组的长度。	

pop() 删除数组中的最后一个元素删除的那个元素 没有参数

Shift（） 删除数组中的第一个元素 没有参数

map( )：没有return时，对数组的遍历。有return时，返回一个新数组，该新数组的元素是经过过滤(逻辑处理)过的函数。

indexOf('元素', n)); 参数一元素，参数二元素出现的次数 返回第n次出现的索引号

lastindexOf('元素') 存在返回元素最后一次出现的索引位置

tostring数组转化为字符串 元素之间用逗号切割

Join（&）分隔符 参数分割方式

concat（‘元素’‘拼在哪个元素后’）拼接在后

replace（ '被替换的字符' '替换后的字符' ）替换第一次出现的元素

substr（截取字符串的起始位置，截取字符串的个数）截取

split('符号')分割符

tostring();转为字符串

charAt（索引号）根据位置返回字符本身

charcodeAt（索引号） 返回相应的索引号值的ascii码，目的：判断用户按下了哪个键

arr[2]返回索引号的值

map() 方法返回一个新数组,新数组中的元素为原始数组中的每个元素调用函数处理后得到的值



Arr.every（）所有的元素通过传入的函数进行判断返回一个布尔值，如果所有的满足返回t，有一个不满足返回f

Arr.some（）所有的元素通过传入的函数进行判断返回一个布尔值，如果只有一个的满足返回t，所有不满足返回freduce 数组进行求和

splice() 方法可以删除从 index 处开始的0或多个元素,并且用参数列表声明中声明的一个或是多个值来代替或修改那些被删除的元素。

## 3.29 字符串常用的方法有哪些？

substr、slice、concat、

slice() 方法以新的数组对象，返回数组中被选中的元素。选择从给定的 start 参数开始的元素，并在给定的 end 参数处结束。

cancat()把两个数组结合成一个

## 3.30 数组怎么进行去重 （3种以上方法）

- 利用ES6 Set去重（ES6中最常用）
- 利用for嵌套for，然后splice去重（ES5中最常用）
- 利用indexOf去重  indexOf(‘元素') 存在返回元素第一次出现的索引位置，从索引0开始 该元素不存在返回-1
- 利用includes  可以判断一个数组中是否包含某一个元素，并返回true 或者false
- 利用filter

## 3.31 数组扁平化 递归###

- #### ES5+递归

- #### ES6+reduce+递归

- ### ES6 Flat函数

- **递归，就是在运行的过程中调用自己。**

  构成递归需具备的条件：
  **1. 子问题须与原始问题为同样的事，且更为简单；
  \2. 不能无限制地调用本身，须有个出口，化简为非递归状况处理。**

## 3.32 什么是纯函数

    纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。

## 3.33 什么是高阶函数，例如递归
   一个函数作为另外一个函数的参数或者一个函数的返回值为另外一个函数这种函数就称之为高阶函数。

## 3.34 函数柯里化及其用途？？？
柯里化，英语：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
应用:
  参考地址: https://blog.csdn.net/qq_18404993/article/details/108836643
 -参数复用

 - 兼容性检测：提前确认/提前返回
 - 延迟执行 
	







## 3.35 怎么解决异步回调地狱问题?

Promise、generator、async await

## 3.36 说一下Promise的使用？ 与async await区别###

Promise是异步编程的一种解决方案，在ES6中Promise被列为了正式规范，统一了用法，原生提供了Promise对象。**Promise承诺：默认情况下是等待状态pending，如果有一天状态转变为成功就成功了，如果状态变成失败就失败了。状态一旦改变了就不能再改变了。**

三种状态： pending，Resolved， Rejected

- then 方法	[promise](https://so.csdn.net/so/search?q=promise&spm=1001.2101.3001.7020)实例状态改变的回调函数，有两个参数：第一个是成功回调函数，第二个是失败回调函数。他会返回一个全新的promise，因此可以继续then链式调用。

- catch的用法    

  失败回调函数，状态变为rejected执行。相当于promise. prototytype.then(null/undifined,rejection)

    如果promise内发生了错误，但却没有定义catch()，这时运行到这一行代码会报错，但是不会影响到promise后面代码的执行

- finally方法   promise实例无论状态是什么都会执行的函数

- all的用法    将多个promise实例包装成一个新的promise实例  

  a. 只有所有实例的状态都变成fulfilled，它才会变成fulfilled；

   b. 只要其中一个实例的状态变为rejected，它就会变成rejected。

- race的用法   将多个promise实例包装成一个新的promise实例   他的状态取决于状态最先改变的实例

- Promise的静态方法   

  async

  用于解决异步回调， 用同步的写法使得可读性更强，同时方便try catch捕获异常

  区别：1.Async Await是基于promise实现，是改良版的promise，使代码看起来更加简洁，异步代码执行像同步代码一样
  
  2.是语法糖
  
  3.减少回调

## 3.37 怎么将伪数组转换成真正的数组？

- ```javascript
  Array.prototype.slice.call(arguments,0) // 使用slice方法实现
  ```

- ```javascript
  Array.from(arguments) // 使用ES6中的函数
  ```

- ```javascript
  [...arguments]
  ```

## 3.38 斐波那契数列怎么实现？

- 第一种实现：普通递归

  ```javascript
  function fibonacci(n) {
      if (n == 1 || n == 2) {
          return 1
      };
      return fibonacci(n - 2) + fibonacci(n - 1);
  }
  fibonacci(30)
  ```

- 第二种实现: 改进递归-把前两位数字做成参数避免重复计算

  ```javascript
  function fibonacci(n) {
      function fib(n, v1, v2) {
          if (n == 1)
              return v1;
          if (n == 2)
              return v2;
          else
              return fib(n - 1, v2, v1 + v2)
      }
      return fib(n, 1, 1)
  }
  fibonacci(30)
  ```

- 第三种实现：改进递归-利用闭包特性把运算结果存储在数组里，避免重复计算

  ```javascript
  var fibonacci = function () {
      let memo = [0, 1];
      let fib = function (n) {
          if (memo[n] == undefined) {
              memo[n] = fib(n - 2) + fib(n - 1)
          }
          return memo[n]
      }
      return fib;
  }()
  fibonacci(30)
  ```

- 第四种实现: 改进递归-摘出存储计算结果的功能函数

  ```javascript
  var memoizer = function (func) {
      let memo = [];
      return function (n) {
          if (memo[n] == undefined) {
              memo[n] = func(n)
          }
          return memo[n]
      }
  };
  var fibonacci=memoizer(function(n){
      if (n == 1 || n == 2) {
          return 1
      };
      return fibonacci(n - 2) + fibonacci(n - 1);
  })
  fibonacci(30)
  ```

- 第五种: 普通for循环

  ```javascript
  function fibonacci(n) {
      var n1 = 1, n2 = 1, sum;
      for (let i = 2; i < n; i++) {
          sum = n1 + n2
          n1 = n2
          n2 = sum
      }
      return sum
  }
  fibonacci(30)
  ```

- 第六种：for循环+解构赋值

  ```javascript
  var fibonacci = function (n) {
      let n1 = 1; n2 = 1;
      for (let i = 2; i < n; i++) {
          [n1, n2] = [n2, n1 + n2]
      }
      return n2
  }
  fibonacci(30)
  ```

  这六种方法需要会 第六种 和 第三种。其他需要了解

## 3.39 冒泡算法

用双重for循环，给数组进行重新排序

```javascript
//从小到大
function BubbleSort(arr){
    var i,j,temp;
    for(i=0;i<arr.length-1;i++){
        for(j=i+1;j<arr.length;j++){
            if(arr[i]>arr[j]){
                temp=arr[j];
                arr[j]=arr[i];
                arr[i]=temp;
            }
        }
    }
    return arr;
}
var arr=[10,7,9,11,22,33,4,2,0,1000];
BubbleSort(arr);  17 console.log(arr); //[0, 2, 4, 7, 9, 10, 11, 22, 33, 1000]
```

## 3.40 快排算法

参考地址： https://www.cnblogs.com/hjx-blog/articles/9183453.html

```javascript
var quickSort_New = function(ary, left, right) {
        if(left >= right) {
            return ary;
        }

        var i = left,
             j = right;
             base = ary[left];

        while (i < j) {
            // 从右边起，寻找比基数小的数
            while (i<j && ary[j] >= base) {
                j--;
            }

            // 从左边起，寻找比基数大的数
            while (i<j && ary[i] <= base) {
                i++
            } 

            if (i<j) {
                var temp = ary[i];
                ary[i] = ary[j];
                ary[j] = temp;
            }
        }

        ary[left] = ary[i];
        ary[i] = base;

        quickSort_New(ary, left, i-1);
        quickSort_New(ary, i+1, right);

        return ary;
    }
```

## 3.41 面向对象继承方式（ES5）

- 原型链的方式来实现继承

- 借用构造函数

- 组合继承

- 寄生式继承

- 寄生式组合继承

## 3.42 EventLoop事件循环

```
JS`是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，`Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval
```

## 3.43 介绍一下垃圾回收机制 ？

垃圾回收机制大体上分为两种检测手段，引用**<u>计数与标记清除</u>**。

从2012年起，所有现代浏览器都使用了标记清除垃圾回收算法，但老版本的IE6除外。

如何避免内存泄漏：

**1.尽量减少全局变量**

**2.移除被遗忘的定时器或回调函数**

**3.及时释放闭包中的变量**

**4.DOM的引用时 不再使用DOM及时清除**

## 3.43 Proxy的作用?有哪些方法？

Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

方法只需记住关键的几个即可：

- **get(target, propKey, receiver)**：拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。 // 记住
- **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。// 记住
- **has(target, propKey)**：拦截`propKey in proxy`的操作，返回一个布尔值。
- **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。 // 记住
- **ownKeys(target)**：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。
- **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。  // 记住
- **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。 // 记住
- **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。
- **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。
- **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。
- **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
- **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。 // 记住
- **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

## 3.44 前端优化之渲染百万条数据不卡顿

参考网址: https://juejin.cn/post/7011040313418448926#heading-7

Document.createDocumentFragment()： 用来创建虚拟DOM

window.requestAnimationFrame：告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

`requestAnimationFrame` 会把每一帧中的所有`DOM`操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。

在隐藏或不可见的元素中，`requestAnimationFrame`将不会进行重绘或回流，这当然就意味着更少的的`cpu`，`gpu`和内存使用量。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <ul></ul>

    <script>
      // createDocumentFragment
      // requestAnimationFrame

      // 百万条数据
      let total = 1000000;
      // 单次插入 可自定义
      let once = 20;
      // 需要插入的次数 向上取整
      let loopCount = Math.ceil(total / once);
      // 当前渲染次数
      let countRender = 0;

      function render() {
        // 需要插入的目标对象
        const targetElement = document.querySelector("ul");
        // 文档因为存在片段于内存中，并不在DOM树中，将所以子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。
        // 创建一个虚拟Dom节点 插入真实文档之前不会触发dom渲染、回流等操作
        // 因此能够很大程度减少dom操作所带来的的性能损耗
        const fragment = document.createDocumentFragment();

        // 对虚拟节点插入dom节点，也不会触发真是dom操作，同上
        for (let i = 0; i < 20; i++) {
          // 搞个节点
          const li = document.createElement("li");
          // 给li搞点内容
          li.innerHTML = Math.random();
          // 插入到虚拟节点
          fragment.appendChild(li);
        }
        // 插入到真实节点的时候，只会把虚拟fragment下的子孙节点插入
        targetElement.appendChild(fragment);
        // 渲染次数加1，控制递归的次数
        countRender++;
        // // 递归调用
        if (countRender < loopCount) {
          // window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。
          // 回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。
          // 能够把每次dom的操作汇总在下一次重绘之前更新动画帧
          // 因此在浏览器单线程的机制下，能够无卡顿的加载，百万级列表
          window.requestAnimationFrame(render);
        }
      }

      // 执行渲染
      render();
    </script>
  </body>
</html>
```

还有一种方案可以提高性能：

如果对于大量的数据，只应用于展示的话，可以使用**`Object.freeze()`** 方法可以**冻结**一个对象。一个被冻结的对象再也不能被修改；（这样可以让Vue不对对象增加getter和setter操作，从而提高性能）

## 3.45 手写实现Promise

```javascript
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';

const resolvePromise = (promise2, x, resolve, reject) => {
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) { 
    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
  }
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === 'object' && x != null) || typeof x === 'function') { 
    try {
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === 'function') { 
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(x, y => { // 根据 promise 的状态决定是成功还是失败
          if (called) return;
          called = true;
          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
          resolvePromise(promise2, y, resolve, reject); 
        }, r => {
          // 只要失败就失败 Promise/A+ 2.3.3.3.2
          if (called) return;
          called = true;
          reject(r);
        });
      } else {
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      }
    } catch (e) {
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e)
    }
  } else {
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4  
    resolve(x)
  }
}

class Promise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) => {
      if(this.status ===  PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=>fn());
      }
    } 

    let reject = (reason) => {
      if(this.status ===  PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=>fn());
      }
    }

    try {
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onFulfilled, onRejected) {
    //解决 onFufilled，onRejected 没有传值的问题
    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };
    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7
    let promise2 = new Promise((resolve, reject) => {
      if (this.status === FULFILLED) {
        //Promise/A+ 2.2.2
        //Promise/A+ 2.2.4 --- setTimeout
        setTimeout(() => {
          try {
            //Promise/A+ 2.2.7.1
            let x = onFulfilled(this.value);
            // x可能是一个proimise
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            //Promise/A+ 2.2.7.2
            reject(e)
          }
        }, 0);
      }

      if (this.status === REJECTED) {
        //Promise/A+ 2.2.3
        setTimeout(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e)
          }
        }, 0);
      }

      if (this.status === PENDING) {
        this.onResolvedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e)
            }
          }, 0);
        });

        this.onRejectedCallbacks.push(()=> {
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            } catch (e) {
              reject(e)
            }
          }, 0);
        });
      }
    });
  
    return promise2;
  }
}

作者：齐小神
链接：https://juejin.cn/post/6850037281206566919
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 3.46 手写bind函数

```javascript
//bind实现要复杂一点  因为他考虑的情况比较多 还要涉及到参数合并(类似函数柯里化)
Function.prototype.myBind = function (context, ...args) {
  if (!context || context === null) {
    context = window;
  }
  // 创造唯一的key值  作为我们构造的context内部方法名
  let fn = Symbol();
  context[fn] = this;
  let _this = this;
  //  bind情况要复杂一点
  const result = function (...innerArgs) {
    // 第一种情况 :若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象
    // 此时由于new操作符作用  this指向result实例对象  而result又继承自传入的_this 根据原型链知识可得出以下结论
    // this.__proto__ === result.prototype   //this instanceof result =>true
    // this.__proto__.__proto__ === result.prototype.__proto__ === _this.prototype; //this instanceof _this =>true
    if (this instanceof _this === true) {
      // 此时this指向指向result的实例  这时候不需要改变this指向
      this[fn] = _this;
      this[fn](...[...args, ...innerArgs]); //这里使用es6的方法让bind支持参数合并
      delete this[fn];
    } else {
      // 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context
      context[fn](...[...args, ...innerArgs]);
      delete context[fn];
    }
  };
  // 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法
  // 实现继承的方式: 使用Object.create
  result.prototype = Object.create(this.prototype);
  return result;
};

//用法如下

// function Person(name, age) {
//   console.log(name); //'我是参数传进来的name'
//   console.log(age); //'我是参数传进来的age'
//   console.log(this); //构造函数this指向实例对象
// }
// // 构造函数原型的方法
// Person.prototype.say = function() {
//   console.log(123);
// }
// let obj = {
//   objName: '我是obj传进来的name',
//   objAge: '我是obj传进来的age'
// }
// // 普通函数
// function normalFun(name, age) {
//   console.log(name);   //'我是参数传进来的name'
//   console.log(age);   //'我是参数传进来的age'
//   console.log(this); //普通函数this指向绑定bind的第一个参数 也就是例子中的obj
//   console.log(this.objName); //'我是obj传进来的name'
//   console.log(this.objAge); //'我是obj传进来的age'
// }

// 先测试作为构造函数调用
// let bindFun = Person.myBind(obj, '我是参数传进来的name')
// let a = new bindFun('我是参数传进来的age')
// a.say() //123

// 再测试作为普通函数调用
// let bindFun = normalFun.myBind(obj, '我是参数传进来的name')
//  bindFun('我是参数传进来的age')

```

## 3.47 RAF 和 RIC 是什么

**requestAnimationFrame：** 告诉浏览器在下次重绘之前执行传入的回调函数(通常是操纵 dom，更新动画的函数)；由于是每帧执行一次，那结果就是每秒的执行次数与浏览器屏幕刷新次数一样，通常是每秒 60 次。

**requestIdleCallback：**: 会在浏览器空闲时间执行回调，也就是允许开发人员在主事件循环中执行低优先级任务，而不影响一些延迟关键事件。如果有多个回调，会按照先进先出原则执行，但是当传入了 timeout，为了避免超时，有可能会打乱这个顺序。

> 这个题目可以深入去问浏览器每一帧的渲染流程 具体可以看看这篇 [requestIdleCallback 和 requestAnimationFrame 详解](https://juejin.cn/post/6844903848981577735)



#  四、网络请求

## 4.1 http中post请求和get请求有什么区别

（1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）

（2）post发送的数据更大（get有url长度限制）

（3）post能发送更多的数据类型（get只能发送ASCII字符）

（4）post比get慢

（5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据

## 4.2 从输入一个 URL 地址到浏览器完成渲染的整个过程？

浏览器地址栏输入 URL 并回车

浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期

DNS 解析 URL 对应的 IP

根据 IP 建立 TCP 连接（三次握手）

发送 http 请求

服务器处理请求，浏览器接受 HTTP 响应

浏览器解析并渲染页面

关闭 TCP 连接（四次握手）

## 4.3 使用什么工具进行post请求的测试

postman

## 4.4 http状态码有哪些

1开头    表示临时响应并需要请求者继续执行操作的状态码。

2开头 （请求成功）表示成功处理了请求的状态代码。

3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。

5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

- 常见状态码

http 状态码 200 （有内容） 服务器成功处理了请求

http 状态码 204 （无内容） 服务器成功处理了请求，但没有返回任何内容

http 状态码 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。

http 状态码 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

http 状态码 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

http 状态码 400 （错误请求） 服务器不理解请求的语法（一般为参数错误）。

http 状态码 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。

http 状态码 403 （禁止） 服务器拒绝请求。（一般为客户端的用户权限不够）

http 状态码 404 （未找到） 服务器找不到请求的网页。

http 状态码 500（服务器内部错误）  服务器遇到错误，无法完成请求。

## 4.5 怎么解决跨域问题

- 后台cors
- 前端使用jsonp请求（后台接口必须支持jsonp）
- 使用反向代理方式

## 4.6  http和TCP协议都什么区别

HTTP是基于TCP的，客户端往服务端发送一个HTTP请求时第一步就是要建立与服务端的TCP连接，也就是先三次握手，“你好，你好，你好”。从HTTP 1.1开始支持持久连接，也就是一次TCP连接可以发送多次的HTTP请求。

小总结：HTTP基于TCP

需要说出TCP三次握手四次挥手。

## 4.7 http和https有什么区别

- HTTP是`明文传输`，不安全的，HTTPS是`加密传输`，安全的多

- HTTP标准端口是`80`，HTTPS标准端口是`443`

- HTTP不用认证证书`免费`，HTTPS需要认证证书`要钱`

- 连接方式不同，HTTP三次握手，HTTPS中TLS1.2版本7次，TLS1.3版本6次

- HTTP在OSI网络模型中是在`应用层`，而HTTPS的TLS是在`传输层`

- HTTP是`无状态`的，HTTPS是`有状态`的

## 4.8 http和websocket协议有什么区别

区分这两个概念是比较有意义的，毕竟TCP看不见摸不着，HTTP与Socket是实实在在能用到的。

- HTTP是短连接，Socket(基于TCP协议的)是长连接。尽管HTTP1.1开始支持持久连接，但仍无法保证始终连接。而Socket连接一旦建立TCP三次握手，除非一方主动断开，否则连接状态一直保持。
- HTTP连接服务端无法主动发消息，Socket连接双方请求的发送先后限制。这点就比较重要了，因为它将决定二者分别适合应用在什么场景下。HTTP采用“请求-响应”机制，在客户端还没发送消息给服务端前，服务端无法推送消息给客户端。必须满足客户端发送消息在前，服务端回复在后。Socket连接双方类似peer2peer的关系，一方随时可以向另一方喊话。
  - 用HTTP的情况：双方不需要时刻保持连接在线，比如客户端资源的获取、文件上传等。
  - 用Socket的情况：大部分即时通讯应用(QQ、微信)、聊天室等等。

## 4.9 请求的步骤是什么？

1.首先,创建一个XMLHttpRequest异步对象

2.然后,设置请求方式和请求地址

3.接着,用send发送请求

4.然后,监听状态变化

## 4.10 浏览器缓存？？？http的强制缓存和协商缓存是什么？？？？？？？

参考地址： https://juejin.cn/post/6974529351270268958#heading-20

- 强制缓存就是文件直接从本地缓存中获取，不需要发送请求。

![强制缓存 图1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5f04f37b588462ab7abf025cfa7c5a8~tplv-k3u1fbpfcp-watermark.awebp)

![强制缓存 图2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a925e79ee724f1099df19d9e61fff32~tplv-k3u1fbpfcp-watermark.awebp)

从上图中可以看到，此时浏览器已经接收到 `cache-control` 的值，那么这个时候浏览器再次发送请求时，它会先检查它的 `cache-control` 是否过期，如果没有过期则直接从本地缓存中拉取资源，返回到客户端，而无需再经过服务器。



- 协商缓存，也叫对比缓存。

  它是一种**服务端的缓存策略**，即通过服务端来判断某件事情是不是可以被缓存。

  服务端判断客户端的资源，是否和服务端资源一样，如果一致则返回 `304` ，反之返回 `200` 和最新的资源。

![协商缓存 图1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5684907367bc4101b4e3f4bc23cdb760~tplv-k3u1fbpfcp-watermark.awebp)

## 4.11 什么是XSS、CSRF攻击

CSRF即Cross-site request forgery(跨站请求伪造)，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。

XSS即Cross Site Scripting（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入JS代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

**如何防御CSRF攻击**

- 验证`Token`：浏览器请求服务器时，服务器返回一个token，每个请求都需要同时带上token和cookie才会被认为是合法请求

- 验证`Referer`：通过验证请求头的Referer来验证来源站点，但请求头很容易伪造

- 设置`SameSite`：设置cookie的SameSite，可以让cookie不随跨域请求发出，但浏览器兼容不一

**如何防御XSS攻击**

- **输入检查**：对输入内容中的`<script><iframe>`等标签进行转义或者过滤
- **设置httpOnly**：很多XSS攻击目标都是窃取用户cookie伪造身份认证，设置此属性可防止JS获取cookie
- **开启CSP**，即开启白名单，可阻止白名单以外的资源加载和运行

## 4.12 如果使用axios取消请求

## 4.13 https 加密过程是怎样的

参考: https://juejin.cn/post/6844904150115827725

我们记住两个主要目的就行：1.对数据加密 2.验证网站服务器身份

##

# 五、Vue面试题

## 5.1 Vue常见的指令

v-text、v-cloak、v-once、v-html、v-on、v-bind

v-text:绑定文本，不能加载标签

v-html:绑定文本，可以加载标签

v-bind: ***\*用于绑定数据和元素属性\****

v-if:条件判断，为真添加元素，为假删除元素

v-for:循环

v-model:双向数据绑定

v-show:条件判断，为真显示，为假不显示 

## 5.2 MVC和MVVM

MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范

- Model（模型）：通常模型对象负责在数据库中存取数据
- View（视图）：是应用程序中处理数据显示的部分。
- Controller（控制器）：是应用程序中处理用户交互的部分。

MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。

##### MVVM

MVVM 新增了 VM 类

- ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。

MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变

整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。

## 5.3 **1.** v-if 与 v-for 为什么不建议一起使用

v-for 和 v-if 不要在同一个标签中使用,因为解析时先解析 v-for (**优先级高**)再解析 v-if (**优先级低**)。如果遇到需要同时使用时可以考虑写成计算属性的方式。



## 5.4 data为什么必须为函数

组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果

## 5.5 插槽有哪些？

设置在自组件内部的`插槽`像一个盒子，位置由子组件决定，放什么内容由父组件决定。

实现了内容分发，提高了组件自定义的程度，让组件变的更加灵活

1. **默认插槽：**

无需`name`属性，取子组件肚子里第一个元素节点作为默认插槽。

​	2.**具名插槽：**

在多个插槽的情况下使用，利用`name`标识插槽。

​	3. **作用域插槽：**

子组件给父组件传递数据。

## 5.6 **1.** Vue循环的key作用

key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速

**更准确**：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。

**更快速**：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快

## 5.7 Vue双向数据绑定原理（响应式原理）1221111

原理:采用数据劫持，结合发布者-订阅者模式的方式，通过Object.defineProperty（）来劫持各个属性的setter/getter，在数据变动时发布消息给订阅者，触发相应监听回调。

用户看不到 setter/getter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

## 5.8 Vue生命周期钩子函数

**beforeCreate** 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问

**created** 实例已经创建完成之后被调用。最早发送请求因为可以最早操作data中的数据以及methods方法

在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom

**beforeMount** 在挂载开始之前被调用：相关的 render 函数首次被调用。

**mounted** 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点

**beforeUpdate** 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程

**updated** 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。

**beforeDestroy** 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。

**destroyed** Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。

**activated** keep-alive 专属，组件被激活时调用

**deactivated** keep-alive 专属，组件被销毁时调用

## 5.9 Vue组件之间数据传递的方式有几种？

props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的

$parent,$children 获取当前组件的父组件和当前组件的子组件

$attrs 和$listeners A->B->C。Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题

父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)

$refs 获取组件实例

eventBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式

vuex 状态管理

## 5.10 VueRouter 路由守卫有哪些？执行顺序是什么？###

1、全局守卫

​	beforeEach 	全局前置守卫

​	beforeResolve	全局解析守卫

​	afterEach  	全局后置守卫

2、独享守卫  

​	beforeEnter

3、 组件内守卫

​	beforeRouteEnter		组件前置守卫 (该守卫没有this)     

​	beforeRouteUpdate  	路由改变但是组件被复用时      

​	beforeRouteLeave  	  组件后置守卫

**完整的导航解析流程:**

1. 导航被触发。
2. 在失活的组件里调用 beforeRouteLeave 组件后置守卫。
3. 调用全局的 beforeEach 全局前置守卫。
4. 在重用的组件里调用 beforeRouteUpdate 守卫	路由改变但是组件被复用时(2.2+)。
5. 在路由配置里调用 beforeEnter独享守卫
6. 解析异步路由组件。
7. 在被激活的组件里调用 beforeRouteEnter组件前置守
8. 调用全局的 beforeResolve 守卫 (2.5+)。
9. 导航被确认。
10. 调用全局的 afterEach 钩子。
11. 触发 DOM 更新。
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

## 5.11  Vue当中的状态管理的作用，以及属性的作用是什么？

vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。

主要包括以下几个模块：

- State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
- Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
- Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。调用方法this.$store.commit()
- Action：用于提交 mutation，可以包含任意异步操作。
- Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

## 5.12  Vue项目当中怎么解决跨域问题？

在前后端分离的网站架构中，服务器经常要配置反向代理，使前端通过固定地址访问后端接口，这样后端服务可以采取负载均衡等性能优化措施，对前端应用透明。

假设前端服务器地址为：`http://127.0.0.1:8080`，后端实际服务地址为：`http://server/web-service/userList` ，由于涉及到跨域的问题，前端无法直接发http请求给此地址，只能发送同域下的api请求例如：`http://127.0.0.1:8080/api/userList`， 通过上文介绍，我们了解到需要在前端服务器上配置反向代理，实现将api请求转发至后台服务器的目的。

在vue.config.js中配置:

```javascript
module.exports = {
    devServer: {
        // 配置反向代理
        proxy: {
            '/': {  // 以/开头的请求
                target: 'https://m.maoyan.com',  // 以/开头的请求，全部代理到https://m.maoyan.com上
                // ws: true,
                changeOrigin: true
            },
            '/foo': {
                target: '<other_url>'
            }
        }
    }
}
```

## 5.13  Vue项目怎么打包app？

- 修改打包后资源引用为相对路径 Vue.config.js 将`baseUrl`改为`'./'`
- 用webpack将项目打包为dist文件 npm run build
- 打开Huilder建h5空项目，  找到刚刚的dist文件夹，进行替换，取好项目名称。
- 右点击项目，将项目转换为App
- 然后进行mainfest文件配置，制作app图标和启动页 点击进行云打包进行打包
- 然后下载打包好之后的.apk文件即可。

## 5.14  怎么解决打包空白问题？

- vue cli4 版本的 配置文件是 vue.config.js , 添加下面红框的内容即可, 将路径设置为相对路径:

![在这里插入图片描述](D:\ftp\210\资料\面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDA0MDEwNw==,size_16,color_FFFFFF,t_70)

- 然后 找到 路由配置 index.js 文件 , 如果 mode 设置的是 history 就注释掉

  ![在这里插入图片描述](D:\ftp\210\资料\面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDA0MDEwNw==,size_16,color_FFFFFF,t_70)

- 重新打包

  ## map和foreach区别？？？？

[foreEach()](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FArray%2FforEach)方法:
针对每一个元素执行提供的函数。
[map()](https://links.jianshu.com/go?to=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FJavaScript%2FReference%2FGlobal_Objects%2FMap)方法:
创建一个新的数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来。

#### 区别

forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。





## 5.15 Vue的diff算法是什么?

简单的来说，就是进行同级比较，新的dom代替旧的dom，没有改变dom的接着使用，用来修改一小段dom，不会引起dom树的重绘，实现了局部更新  

## 5.16 v-if 和 v-show 的区别 

v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。通过dom运算操作

v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏   通过css样式（display:none）

**使用场景**

v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景

v-show 适用于需要非常频繁切换条件的场景

## 5.17 computed 和 watch 的区别和运用的场景

computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。

watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。

计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑



# 计算属性与methods的区别###

1、既然计算属性computed都叫属性了，那么他就是可以当作属性来使用，可以修改;而method是当作方法来使用，它也可以获取值，只不过是return返回值

2、computed有getter和setter进行赋值.而method不行；

3、计算不行不能传值，虽然你在定义的时候看上去是方法computed(){},但是他不能像方法那样可以进行传递参数

4、computed如果数据不变是可以进行缓存的，而方法不行只要是在页面中使用了方法，那么使用几次久会调用方法几次，而computer不会



1.两者计算结果都是相同

2.计算属性是基于他们的依赖进行缓存的，计算属性只有在与它相关联的依赖发生改变时才会重新调用求职;

3.methods方法依赖的是页面渲染，只要页面渲染这个methods方法就会被重新调用

## 5.18 Vue 如何检测数组变化

数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写(AOP 切片思想)

- `push()`方法可以在数组的末属添加一个或多个元素
- `shift()`方法把数组中的第一个元素删除
- `unshift()`方法可以在数组的前端添加一个或多个元素
- `pop()`方法把数组中的最后一个元素删除

所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新

## 5.19 vue3.0 用过吗 了解多少  vue3组合api#########################

- 响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty

- 组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。

- 模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级

- 其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。

  Vue3.0 新特性以及使用经验总结 [传送门](https://juejin.cn/post/6940454764421316644)
  
- 组合式api

- reactive、ref、set、observable、directives

## 5.23 Vue3.0 和 2.0 的响应式原理区别

Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。

**Proxy的优势**如下:

- Proxy可以直接监听对象而非属性
- Proxy可以直接监听数组的变化
- Proxy有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的
- Proxy返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改
- Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

**Object.defineProperty的优势**如下:

- 兼容性好,支持IE9

## 5.24 虚拟 DOM 是什么 有什么优缺点

由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象。

**优点：**

1. 保证性能下限：框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
2. 无需手动操作 DOM：只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
3. 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

**缺点:**

1. 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
2. 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。

## 5.25 Vuex 页面刷新数据丢失怎么解决

需要做 vuex 数据持久化 一般使用**本地存储**的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件

推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中

## 5.26 Vuex 为什么要分模块并且加命名空间

**模块**:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。

**命名空间**：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。

## 5.27 使用过 Vue SSR 吗？说说 SSR   seo搜索引擎

SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。

**优点：**

SSR 有着更好的 SEO、并且首屏加载速度更快

**缺点：** 开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。

服务器会有更大的负载需求

## 5.28 vue 中使用了哪些设计模式

1.工厂模式 - 传入参数即可创建实例

虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode

2.单例模式 - 整个程序有且仅有一个实例

vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉

3.发布-订阅模式 (vue 事件机制)

4.观察者模式 (响应式数据原理)

5.装饰模式: (@装饰器的用法)

6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略

...其他模式欢迎补充

## 5.29 你都做过哪些 Vue 的性能优化

**一：**

对象层级不要过深，否则性能就会差

不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）

v-if 和 v-show 区分使用场景

computed 和 watch 区分使用场景

v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if

大数据列表和表格性能优化-虚拟列表/虚拟表格

防止内部泄漏，组件销毁后把全局变量和事件销毁

图片懒加载

路由懒加载

第三方插件的按需引入

适当采用 keep-alive 缓存组件

防抖、节流运用

服务端渲染 SSR or 预渲染

**二：**

**编码阶段**

- 不要在模板里面写过多表达式
- 尽量减少`data`中的数据，`data`中的数据都会增加`getter`和`setter`，会收集对应的`watcher`
- `v-if`和`v-for`不能连用
- 如果需要使用`v-for`给每项元素绑定事件时使用事件代理
- `SPA` 页面采用`keep-alive`缓存组件
- 频繁切换的使用v-show，不频繁切换的使用v-if
- 循环调用子组件时添加key，`key`保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

**SEO搜索引擎优化**

- 预渲染
- 服务端渲染`SSR`，`nuxt.js`

**打包优化**

- 压缩代码
- `Tree Shaking/Scope Hoisting`
- 使用`cdn`加载第三方模块
- 多线程打包`happypack`
- `splitChunks`抽离公共文件
- `sourceMap`优化

**用户体验**

- 骨架屏
- `PWA`渐进式Web应用，使用多种技术来增强web app的功能，让网页应用呈现和原生应用相似的体验。

> 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启`gzip`压缩等。



## 5.30 Vue.mixin 的使用场景和原理

mixin是为了让可复用的功能灵活的混入到当前组件中，混合的对象可以包含任意组件选项（[生命周期](https://so.csdn.net/so/search?q=生命周期&spm=1001.2101.3001.7020)，指令之类等等）, mixin翻译过来叫混合,高级的词汇可以叫插件入侵

```dart
1、混入对象的钩子将在组件自身钩子之前调用。
mixins:局部混入
mixin:全局混入，一旦使用全局混入对象，将会影响到所有之后创建的 Vue 实例
```

在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。

## 5.31 nextTick 使用场景和原理

nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法。



## 5.32 keep-alive 使用场景和原理

keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。

原理： 

- 常用的两个属性 include/exclude，允许组件有条件的进行缓存。
- 两个生命周期  进入activated/deactivated退出，用来得知当前组件是否处于活跃状态。
- keep-alive 的中还运用了 LRU(最近最少使用) 算法 （超过keep-alive最大的保存长度就会删除），选择最近最久未使用的组件予以淘汰。

## 5.33 Vue.set 方法原理

了解 Vue 响应式原理的同学都知道在两种情况下修改数据 Vue 是不会触发视图更新的

1.在实例创建之后添加新的属性到实例上（给响应式对象新增属性）

2.直接更改数组下标来修改数组的值

Vue.set 或者说是$set 原理如下

因为响应式数据 我们给对象和数组本身都增加了__ob__属性，代表的是 Observer 实例。当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪 然后会触发对象__ob__的 dep 收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组

###每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。

```
export function set (target: Array<any> | Object, key: any, val: any): any {
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }
　　// 判断目标值是否为数组，并且key值是否为有效的数组索引
  if (Array.isArray(target) && isValidArrayIndex(key)) {
　　// 对比数组的key值和数组长度，取较大值设置为数组的长度
    target.length = Math.max(target.length, key)
　　// 替换目标值
    target.splice(key, 1, val)
    return val
  }
　　// 如果目标值是对象，并且key值是目标值存在的有效key值，并且不是原型上的key值
  if (key in target && !(key in Object.prototype)) {
　　// 直接更改目标值
    target[key] = val
    return val
  }
  const ob = (target: any).__ob__ // 判断目标值是否为响应式的
  if (target._isVue || (ob && ob.vmCount)) { // 如果是vue根实例，就警告
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }
  if (!ob) { // 如果目标值不是响应式的，那么值需要给对应的key赋值
    target[key] = val
    return val
  }
　　// 其他情况，目标值是响应式的，就通过Object.defineProperty进行数据监听
  defineReactive(ob.value, key, val)
　　// 通知更新dom操作
  ob.dep.notify()
  return val
}
复制代码
大概流程就是：

　　1.判断目标值是否为有效值，不是有效值直接停止

　　2.判断是否为数组，并且key值是否为有效的key值

　　　　如果是数组，就选择数组的长度和key值取较大值作为数组的新的length值，并且替换目标值

　　　　splice方法，重写了，所以执行splice，会双向数据绑定

　　3.判断目标值是否为响应式的__ob__

　　　　如果是vue实例，直接不行

　　　　如果不是响应式的数据，就是普通的修改对象操作

　　　　如果是响应式数据，那就通过Object.defineProperty进行数据劫持

　　4.通知dom更新
```



## 5.34 Vue.extend 作用和原理

官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并

extend的作用是继承当前的Vue类，传入一个extendOption生成一个新的构造函数。在extend的时候会进行mergeOption，融合Vue原型上的baseOption，所以extend出来的子类也能使用v-model、keep-alive等全局性的组件。

作用是生成组件类。在挂载全局组件和设置了components属性的时候会使用到。在生成DOM的时候会new 实例化挂载。

## 5.35 写过自定义指令吗 原理是什么vue2

指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。

自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind

1. **bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。** 

2. **inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。** 
3. **update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新**
4. **componentUpdated：被绑定元素所在模板完成一次更新周期时调用。**
5.  **unbind：只调用一次，指令与元素解绑时调用。**

**原理**

1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性

2.通过 genDirectives 生成指令代码

3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子

4.当执行指令对应钩子函数时，调用对应指令定义的方法

## 5.36 Vue 修饰符有哪些

**事件修饰符**

- .stop 阻止事件继续传播
- .prevent 阻止标签默认行为
- .capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理
- .self 只当在 event.target 是当前元素自身时触发处理函数
- .once 事件将只会触发一次
- .passive 告诉浏览器你不想阻止事件的默认行为

**v-model 的修饰符**

- .lazy 通过这个修饰符，转变为在 change 事件再同步
- .number 自动将用户的输入值转化为数值类型
- .trim 自动过滤用户输入的首尾空格

**键盘事件的修饰符**

- .enter
- .tab
- .delete (捕获“删除”和“退格”键)
- .esc
- .space
- .up
- .down
- .left
- .right

**系统修饰键**

- .ctrl
- .alt
- .shift
- .meta

**鼠标按钮修饰符**

- .left
- .right
- .middle

## 5.37 Vue 模板编译原理

Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步：

第一步是将 模板字符串 转换成 element ASTs（ast抽象语法树）（解析器） 

第二步是对 AST 进行静态节点标记，主要用来做虚拟DOM的渲染优化（优化器） 

第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）

## 5.38 能说下 vue-router 中常用的路由模式实现原理吗

vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：

```
switch (mode) {
  case 'history':
	this.history = new HTML5History(this, options.base)
	break
  case 'hash':
	this.history = new HashHistory(this, options.base, this.fallback)
	break
  case 'abstract':
	this.history = new AbstractHistory(this, options.base)
	break
  default:
	if (process.env.NODE_ENV !== 'production') {
	  assert(false, `invalid mode: ${mode}`)
	}
}
复制代码
```

其中，3 种路由模式的说明如下：

- hash:  使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；
- history :  依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；
- abstract :  支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.



**hash 模式**

1. location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
2. 可以为 hash 的改变添加监听事件

```javascript
window.addEventListener("hashchange", funcRef, false);
复制代码
```

每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了

> 特点：兼容性好但是不美观

**history 模式**

利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。

这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。

## 5.39 vue3.0 特性你有什么了解的吗？

- 响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty
- 组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。
- 模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级
- 其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。

Vue3.0 新特性以及使用经验总结 [传送门](https://juejin.cn/post/6940454764421316644)

## 5.40 说说你对 SPA 单页面的理解，它的优缺点分别是什么？

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

**优点：**

- 用户体验好、快，内容的改变**不需要重新加载整个页面**，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

## 5.41 `$route`和`$router`的区别

- $route是`路由信息对象`，包括path，params，hash，query，fullPath，matched，name等路由信息参数。
- 而$router是`路由实例`对象包括了路由的跳转方法，钩子函数等。

## 5.42 vue-router路由懒加载

像 vue 这种单页面应用，如果没有路由懒加载，运用 webpack 打包后的文件将会很大，造成进入首页时，需要加载的内容过多，出现较长时间的白屏，运用路由懒加载则可以将页面进行划分，需要的时候才加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。

- 参考: [vue路由懒加载](https://juejin.cn/post/6895546761255845901#heading-4)

vue 路由懒加载有以下三种方式：

1. vue 异步组件

2. ES6 的 import()

3. webpack 的 require.ensure()

   webpack中的require.ensure()可以实现按需加载资源包括js,css等，它会给里面require的文件单独打包，不和主文件打包在一起，webpack会自动配置名字，如0.js,1.js,但是这样看着不是很直观，所以要自己配置单独打包的chunk名字

## 5.43 Vue Diff算法？

参考: https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3c68d1b0884d9ca0f8ffc5ee64a28e~tplv-k3u1fbpfcp-watermark.awebp

参考: https://juejin.cn/post/6953433215218483236

## 5.44 如何使用v-model封装自定义组件或者UI组件？（二次封装）

参考: https://www.jianshu.com/p/f288b27171b3

# 六、项目内容

## 6.1 Vue项目的难点有哪些？

## 6.2 Vue项目上线之前做了哪些优化？

## 6.3 uniapp项目的难点有哪些？

## 6.4 uniapp项目上线之前做了哪些优化？

https://juejin.cn/post/6997224351346982942

## 6.5 Webpack 有哪些优化手段

参考： https://juejin.cn/post/6844904093463347208

## 6.6 babel 是什么，原理了解吗

Babel 是一个 JavaScript 编译器。他把最新版的 javascript 编译成当下可以执行的版本，简言之，利用 babel 就可以让我们在当前的项目中随意的使用这些新最新的 es6，甚至 es7 的语法。

Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。

- 解析 将代码解析成抽象语法树（AST），每个 js 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的 AST 解析器，而 Babel 是通过 Babylon 实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构。
- 转换 在这个阶段，Babel 接受得到 AST 并通过 babel-traverse 对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是 Babel 插件介入工作的部分。
- 生成 将经过转换的 AST 通过 babel-generator 再转换成 js 代码，过程就是深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。

还想深入了解的可以看 [[实践系列\]Babel 原理](https://juejin.cn/post/6844903760603398151)



# 七、设计模式

## 7.1 观察者模式、发布-订阅模式篇

```javascript
/**
 * @description 观察者模式实现
 */
// 目标对象
class Subject {
    constructor() {
        // 维护一个观察者集合
        this.observerList = [];
    }
    // 添加观察者
    addObserver(observer) {
        // 避免重复添加观察者
        if(this.observerList.includes(observer)) return;
        this.observerList.push(observer);
    }
    // 删除指定观察者，不支持全部删除，风险较高
    removeObserver(observer) {
        if(!observer) return;
        this.observerList = this.observerList.filter(i => i !== observer);
    }
    // 通知观察者
    notify() {
        // 若无观察者，也就不通知了
        if(!this.observerList) return;
        // 遍历调用观察者的 update 方法
        this.observerList.forEach(observer => {
            if(observer.update && Object.prototype.toString.call(observer.update).slice(8, -1) === "Function") {
                observer.update();
            }
        });
    }
}
// 观察者
class Observer {
    update() {
        console.log("我观察到了目标对象的变化");
    }
}

作者：博小魏
链接：https://juejin.cn/post/7035247560918990884
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 7.2 单例模式

顾名思义单例就是多次执行都只会生成这一个对象。

参考地址: https://blog.csdn.net/loringray/article/details/104585104

## 7.3 工厂模式

参考:  https://segmentfault.com/a/1190000012422198

# 八、Typescript

## 8.1 ts中的访问修饰符 1

- public，任何地方
- private，只能在类的内部访问
- protected，能在类的内部访问和子类中访问
- readonly，属性设置为只读

## 8.2 const和readonly的区别 

- const用于变量，readonly用于属性

- const在运行时检查，readonly在编译时检查

- 使用const变量保存的数组，可以使用push，pop等方法。但是如果使用`ReadonlyArray<number>`声明的数组不能使用push，pop等方法。

## 8.3 枚举和常量枚举（const枚举）的区别

1. 枚举会被编译时会编译成一个对象，可以被当作对象使用

2. const枚举会在ts编译期间被删除，避免额外的性能开销

   ```typescript
   // 普通枚举
   enum Witcher {
     Ciri = 'Queen',
     Geralt = 'Geralt of Rivia'
   }
   function getGeraltMessage(arg: {[key: string]: string}): string {
     return arg.Geralt
   }
   getGeraltMessage(Witcher) // Geralt of Rivia
   
   
   
   // const枚举
   const enum Witcher {
     Ciri = 'Queen',
     Geralt = 'Geralt of Rivia'
   }
   const witchers: Witcher[] = [Witcher.Ciri, Witcher.Geralt]
   // 编译后
   // const witchers = ['Queen', 'Geralt of Rivia'
   
   ```

## 8.4 ts中interface可以给Function/Array/Class做声明吗？

   可以的

## 8.5 ts中和js有什么差异？



## 8.6 ts中如何枚举联合类型的key?

   ```typescript
   type Name = { name: string }
   type Age = { age: number }
   type Union = Name | Age
   
   type UnionKey<P> = P extends infer P ? keyof P : never
   
   type T = UnionKey<Union>
   ```

## 8.7 ts中 ?.、??、!.、_、** 等符号的含义？ 1

   ?.  可选链

   ??  ?? 类似与短路或，??避免了一些意外情况0，NaN以及"",false被视为false值。只有undefind,null被视为false值。

   !.  在变量名后添加!，可以断言排除undefined和null类型

   _ , 声明该函数将被传递一个参数，但您并不关心它

   ** 求幂

   !:，待会分配这个变量，ts不要担心

   ```typescript
   // ??
   let x = foo ?? bar();
   // 等价于
   let x = foo !== null && foo !== undefined ? foo : bar();
   
   // !.
   let a: string | null | undefined
   a.length // error
   a!.length // ok
   
   作者：dyhtps
   链接：https://juejin.cn/post/6988763249982308382
   来源：稀土掘金
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
   ```

   

## 8.8 什么是抗变、双变、协变和逆变？

   Covariant 协变，TS对象兼容性是协变，父类 <= 子类，是可以的。子类 <= 父类，错误。

   Contravariant 逆变，禁用`strictFunctionTypes`编译，函数参数类型是逆变的，父类 <= 子类，是错误。子类 <= 父类，是可以的。

   Bivariant 双向协变，函数参数的类型默认是双向协变的。父类 <= 子类，是可以的。子类 <= 父类，是可以的。

## 8.9 ts中同名的interface或者同名的interface和class可以合并吗？

   1. interface会合并
   2. class不可以合并

## 8.10 如何使ts项目引入并识别编译为js的npm库包？

   1. `npm install @types/xxxx`
   2. 自己添加描述文件

tsc ts文件名称。编译之后会产生同样的js文件编译后引入js

有js和ts时引入js 纯js可以引入ts

## 8.11 ts如何自动生成库包的声明文件？

   可以配置`tsconfig.json`文件中的`declaration`和`outDir`

   1. declaration: true, 将会自动生成声明文件
   2. outDir: '', 指定目录

## 8.12 什么是泛型 1

   泛型用来来创建可重用的组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。**简单的说，“泛型就是把类型当成参数”。**

## 8.13 -?，-readonly 是什么含义 1

   用于删除修饰符

   ```typescript
   type A = {
       a: string;
       b: number;
   }
   
   type B = {
       [K in keyof A]?: A[K]
   }
   
   type C = {
       [K in keyof B]-?: B[K]
   }
   
   type D = {
       readonly [K in keyof A]: A[K]
   }
   
   type E = {
       -readonly [K in keyof A]: A[K]
   }
   
   作者：dyhtps
   链接：https://juejin.cn/post/6988763249982308382
   来源：稀土掘金
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
   ```

## 8.14 TS是基于结构类型兼容

   typescript的类型兼容是基于结构的，不是基于名义的。下面的代码在ts中是完全可以的，但在java等基于名义的语言则会抛错。

   ```typ
   interface Named { name: string }
   class Person {
     name: string
   }
   let p: Named
   // ok
   p = new Person()
   ```

## 8.15 const断言

   const断言，typescript会为变量添加一个自身的字面量类型

   1. 对象字面量的属性，获得readonly的属性，成为只读属性
   2. 数组字面量成为readonly tuple只读元组
   3. 字面量类型不能被扩展（比如从hello类型到string类型）

   ```typescript
   // type '"hello"'
   let x = "hello" as const
   // type 'readonly [10, 20]'
   let y = [10, 20] as const
   // type '{ readonly text: "hello" }'
   let z = { text: "hello" } as const
   
   作者：dyhtps
   链接：https://juejin.cn/post/6988763249982308382
   来源：稀土掘金
   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
   ```

## 8.16 type 和 interface 的区别 1

   1. 类型别名可以为任何类型引入名称。例如基本类型，联合类型等
   2. 类型别名不支持继承
   3. 类型别名不会创建一个真正的名字
   4. 类型别名无法被实现(implements)，而接口可以被派生类实现
   5. 类型别名重名时编译器会抛出错误，接口重名时会产生合并

## 8.17 implements 与 extends 的区别

   - extends, 子类会继承父类的所有属性和方法。
   - implements，使用implements关键字的类将需要实现需要实现的类的所有属性和方法。

## 8.18 枚举和 object 的区别 1

   枚举可以通过枚举的名称，获取枚举的值。也可以通过枚举的值获取枚举的名称。

   object只能通过key获取value

   数字枚举在不指定初始值的情况下，枚举值会从0开始递增。

   虽然在运行时，枚举是一个真实存在的对象。但是使用keyof时的行为却和普通对象不一致。必须使用keyof typeof才可以获取枚举所有属性名。

## 8.19 never, void 的区别 1

   never，never表示永远不存在的类型。比如一个函数总是抛出错误，而没有返回值。或者一个函数内部有死循环，永远不会有返回值。函数的返回值就是never类型。

   void, 没有显示的返回值的函数返回值为void类型。如果一个变量为void类型，只能赋予undefined或者null。

## 8.20 unknown, any的区别

   unknown类型和any类型类似。与any类型不同的是。unknown类型可以接受任意类型赋值，但是unknown类型赋值给其他类型前，必须被断言

## 8.21 如何在 window 扩展类型

   ```typescript
   declare global {
     interface Window {
       myCustomFn: () => void;
     }
   }
   ```

## 8.22 元祖越界问题

   ```typescript
   let aaa: [string, number] = ['aaa', 5];
   // 添加时不会报错
   aaa.push(6);
   // 打印整个元祖不会报错
   console.log(aaa); // ['aaa',5,6];
   // 打印添加的元素时会报错
   console.log(aaa[2]); // error
   
   ```

## 8.23 重写(override) vs 重载(overload)

   - **重写是指子类重写“\**\*\*继承\*\**\*”自父类中的方法** 。虽然 TS 和JAVA 相似，但是 TS 中的继承本质上还是 JS 的“**继承**”机制—**原型链机制**

   - **重载是指为同一个函数提供多个类型定义**

     ```typescript
     class Animal {
         speak(word: string): string {
             return '动作叫:' + word;
         }
     }
     
     class Cat extends Animal {
         speak(word: string): string {
             return '猫叫:' + word;
         }
     }
     
     let cat = new Cat();
     console.log(cat.speak('hello'));
     
     /**--------------------------------------------**/
     
     function double(val: number): number
     function double(val: string): string
     function double(val: any): any {
         if (typeof val == 'number') {
             return val * 2;
         }
         return val + val;
     }
     
     let r = double(1);
     console.log(r);
     
     ```

## 8.24 ts常见问题。元祖interface？？/？？/

     https://juejin.cn/post/6929038446837104647

// Tuple 元组

// 元组和数组非常相似，只不过它将类型写在了里面，这就对每一项起到了限定作用;

interface接口通常就是用来定义个一个对象类型数据

// interface接口类型 所定义的对象属性和类型必须一一对应；

# 九、微信小程序

## 9.1 小程序的双向绑定和vue哪里不一样?

小程序直接 this.data 的属性是不可以同步到视图的，必须调用：

```
this.setData({
    // 这里设置
})
```

## 9.2小程序页面间有哪些传递数据的方法?###############

- **使用全局变量实现数据传递**

- **使用 wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候初始化**

- **使用本地缓存**

  ## 9.3 小程序页面的生命周期函数  及其App生命周期函数#####

**页面生命周期：**

onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数

onShow() 页面显示/切入前台时触发

onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互

onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等

onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时

**APP生命周期:**

- onLaunch()  监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
- onShow()    监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow
- onHide()     监听小程序隐藏 当小程序从前台进入后台，会触发 onHide
- onError()     错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息

## 9.4 微信小程序的优劣势

**优势**

- 即用即走，不用安装，省流量，省安装时间，不占用桌面
- 依托微信流量，天生推广传播优势
- 开发成本比 App 低

**缺点**

- 用户留存，即用即走是优势，也存在一些问题
- 入口相对传统 App 要深很多
- 限制较多,页面大小不能超过2M。不能打开超过10个层级的页面

## 9.5 **如何实现下拉刷新**

首先在全局 config 中的 window 配置 enablePullDownRefresh
 在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法
 请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新

## 9.6 bindtap和catchtap的区别是什么?

**相同点**：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分
**不同点**：他们的不同点主要是bindtap是不会阻止冒泡事件的，catchtap是阻止冒泡的

## 9.7 简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?

wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 wx.redirectTo()：关闭当前页面，跳转到新的页面（类似重定向）。但是不允许跳转到 tabbar 页面
 wx.switchTab()：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
 wx.navigateBack():关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层
 wx.reLaunch()：关闭所有页面，打开到应用内的某个页面

## 9.8 **登录流程？**

登录流程是调wx.login获取code传给后台服务器获取微信用户唯一标识openid及本次登录的会话密钥（session_key、token）等）。拿到开发者服务器传回来的会话密钥（session_key、token）之后，前端要保存wx.setStorageSync('sessionKey', 'value')或者wx.setStorageSync('token', 'value')

持久登录状态：session或者token信息存放在cookie或者header的Authorization中以请求头的方式带回给服务端，放到request.js里的wx.request的header里。

## 9.9 小程序父子组件之间的传参？

父向子:   properties

子向父: triggerEvent

## 9.10 哪些方法可以用来提高微信小程序的应用速度？

1、提高页面加载速度

2、用户行为预测

3、减少默认 `data` 的大小

4、组件化方案

5、分包

## 9.11 小程序支付的流程？

查看登录，创建订单，发送请求，后台生成订单并返回参数，包括：时间戳、随机字符串、package（prepay_id）、签名等。再调取 `wx.requestPayment` 进行支付



- 1.  打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单
- 2.  如果用户没有登录，则跳转登录页面或者弹出登录窗口，需要点击一键登录，登录流程过程跳转到之前的下单页面
- 3. 登录完成后需要将小明购买的商品Id，商品数量，以及小明这个用户的Token传送到服务器，进行创建订单
- 4. 服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)
- ​    5. 小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付

  具体参数:

```javascript
  // 时间戳  timeStamp: '', 

  // 随机字符串  nonceStr: '', 

  // 统一下单接口返回的 prepay_id 参数值  package: '',

  // 签名类型  signType: '',  

  // 签名  paySign: ''
```

监听物理件

plus.key.addeventlist

## 10.1return，break，continue的区别是什么

return	必须写在函数内部，遇到return后函数内部剩余的代码不再执行，直接返回；还可以使用return返回一个值给外面使用

break	跳出循环，剩余的循环不再执行 

continue 跳出本次循环，剩余的循环继续执行

## 10.2typeof和instance of 的区别是什么

  typeof判断对象的类型，返回值有6种可能

  instance of 判断是否是对方的实例化对象，返回值为true或者false 

## 10.3 js的强制转换和隐式转换是怎样的

  parseInt,parseFloat,Number 这三种是强制转换

  -=、*=、/=、%= 是隐式转换 

## **一：什么是跨域**

跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。浏览器从一个域名的网页去请求另一个域名的资源时，出现域名、端口、协议任一不同，都属于跨域。

## 10.4jsonP的作用是什么，原理是什么

作用:解决跨域问题

 	原理:script中的src不受跨域的限制

## 10.5 template标签的作用

 	将元素包裹在一起，本身并不会加载到DOM结构当中

如果多个标签需要进行判断怎么办？就可以利用template标签不会加载在dom结构中进行包裹

## 10.6. transition标签的作用

 设置过渡效果，里面只能放置一个元素，且必须配合v-if、 v-show（或者动态组件、组件根节点）来使用

如果想要设置多个元素渐变，需要使用transition-group

## 10.7vue3的生命周期函数？

setup()相当于beforeCreate+created

onBeforeMount()

onMounted()

onBeforeUpdate()

onUpdated()

onBeforeUnmount()

onUnmounted()

10. ## 8mounted和created的区别？

在于真实的dom是否被创建出来

## 10.9三种路由传值？

1 在路径后面使用： 声明一个变量，调用路径后面跟一个参数 拿到值的话 this.$route.params.变量名，

2.使用path来匹配路由，然后通过query来传递参数 ， 拿到值要 this.$route.qurey.变量名

3.使用name名来匹配路由，要使用params来传递参数，拿到值的话使用this.$route.params.变量名

## 10.10路由当中的hash（哈希）模式和history（历史）模式有什么区别？

Hash:url地址后面会跟一个#，地址切换不会导致页面请求

History:地址后面没有#，地址切换会导致页面请求 

## 10.12vue全家桶一般都有什么，作用是什么

Vue-router 路由管理 创建配置路由 

Vuex 状态管理 统一管理 页面所需的数据  供全局使用

Vue-cli 用来搭建vue项目

Axios 用来数据请求

## 10.13vant、element、meiziUi组件库分别有什么区别

vant:主要做移动端商城类项目

element:是主要做pc端网页

amaze：主要做移动端

## 10.14模块化分类有哪些

A. 浏览器端的模块化 

（1）AMD(Asynchronous Module Definition,异步模块定义) 代表产品为：Require.js 	

（2）CMD(Common Module Definition,通用模块定义) 代表产品为：Sea.js 

B. 服务器端的模块化，服务器端的模块化规范是使用CommonJS规范：

\1. 使用require引入其他模块或者包 

\2. 使用exports或者module.exports导出模块成员 

\3. 一个文件就是一个模块，都拥有独立的作用域 

## 10.15模块化分类有哪些

C. ES6模块化，ES6模块化规范中定义：

1.每一个js文件都是独立的模块

2.导入模块成员使用import关键字 

3.暴露模块成员使用export关键字

小结：推荐使用ES6模块化，因为AMD，CMD局限使用于浏览器端，

CommonJS在服务器端使用，

ES6模块化是浏览器端和服务器端通用的规范.

## 10.17webpack的作用是什么

webpack是一个流行的前端项目构建工具，提供了模块化支持，代码压缩混淆，解决兼容问题，性能优化等特性，提高了开发效率和项目的可维护性。

\1. 对代码重新加载翻译。

\2. 合并静态资源，减少io

\4. webpack的安装命令是什么

npm install webpack webpack-cli -D

## 18webpack当中的development和pruduction有什么区别

前者为开发模式，代码不会进行压缩，打包速度也更快

 后者是生产模式，代码会进行压缩，打包速度相对较慢

## 19如何配置webpack的出口和入口

在webpack.config.js当中设置entry字段，该字段用来配置文件的入口，默认为src下的index.js 

在webpack.config.js当中设置output字段，该字段用来配置文件的出口，默认为dist文件下的main.js

## 20如何配置webpack自动打包的功能 

 A.安装自动打包功能的包:webpack-dev-server

​    npm install webpack-dev-server -D

 B.修改package.json中的dev指令如下：

​    "scripts":{

​      "dev":"webpack-dev-server"

​    }

C.将引入的js文件路径更改为：<script src="/bundle.js"></script>（绝对路径）

D.运行npm run dev，进行打包

## 20webpack怎么打包非js文件

下载文件对应的加载器，然后再webpack.config.js当中配置module的语法规则

## 10.21webpack如何打包css文件

下载style-loader 和 css-loader,然后再webpack.config.js当中配置语法规则

## 10,22webpack如何打包less文件

下载less、less-loader、css-loader、style-loader，然后配置语法规则 

## 0.23webpack如何打包图片文件？？？？？

​	下载url-loader、file-loader ，配置语法规则

## 24webpack打包非vue？？？？

①. npm init 初始项目

②. 安装webpack及web -cli

③. 配置打包入口（entry）/出口（output）

④. 设置自动打包

## 0.25微信小程序当中如何获取用户信息

wx.getUserInfo

## 0.26如何让页面滚动到指定位置 

wx.pageScrollTop

## 27微信怎么进行数据请求，下载和上传

数据请求：wx.request 

上传:wx.uploadFile 

下载:wx.downloadFile

##  0.28微信小程序如何获取自己的地理位置信息

wx.getLocation 可以获取当前的地理位置、速度等信息

# ***\*git\****

一. 平时是怎么进行团队合作的

\1. 首先会确定好需求，UI设计师根据需求设计效果图,效果图客户通过后，UI设计师会给前端一份标注图和切图，同时前后端根据需求开发页面和进行服务器开发

\2. 服务器接口是后端给的，会给一份开发者文档，里面有各个需求请求接口地址、请求类型、参数和返回值等信息

\3. 前端组各个成员会使用git进行代码提交，每天上班时会将最新的代码pull一下，下班前会将代码push上去

二如何解决代码冲突问题

\1. 首先将自己的代码提交到本地仓库

\2. 然后将最新的代码从云仓库拉下来

\3. 进行代码合并，如果合并过程当中冲突，手动解决冲突（删除多余的代码或者合并两份代码）

\4. 解决完冲突以后，重新提交到本地，最后上传到云仓库就行了

\3. 平时使用git版本工具有哪些

\1. 习惯使用命令行提交

\2. 工具使用过sourceTree , 以及git自带的提交工具

\4. git和SVN有什么区别

\1. 平时只用了git

\2. git是分布式的，svn是集中式的

\3. git仓库可以克隆在本地，svn只可以存储在云上

\4. git支持离线提交，svn只能在线提交

四. git常用的命令有哪些

\1. git status 		查看代码状态

\2. git add . 		保存代码到暂存区

\3. git commit -m  保存代码到持久区

\4. git pull 		将云仓库的代码拉下来

\5. git push 		上传代码到云上

\6. git clone 		将云仓库代码克隆到本地

\7. git merge XX 	合并分支，合并分支的时候只允许在主枝合并

8.git checkout xx 切换分支

创建分支git branch xx



## ***\****\*微信直播功能如何实现\****直播功能如何实现：\****

利用微信里面自带的直播组件live-player-plugin代码包配置引入，直接通过链接地址跳转到直播组件页面（即为进直播间页面），链接地址需要带上直播房间 id；房间 id 可通过下面 [获取直播房间列表](https://developers.weixin.qq.com/miniprogram/dev/framework/liveplayer/studio-api.html) API 获取。

## ***\*微信拨电话页面\****

调用微信里面自带的api  wx.makePhoneCall

## ***\*第三方登录\****

开发者 通过 在微信公众号 设置 由第三方 代替 公众号 授权登录 

用户同意授权 拿到 code 

用code 换取 网页授权 access token 

拉取用户信息 

验证 授权 access token 是否有效

## ***\*支付（vue） app 的话，\****

用支付宝就去支付宝公众平台创建项目，

下载安装密钥生成工具 获取密钥 注册成 功后，

把里面代码商家信息和订单信息修改下就行

## **App客服功能怎么实现的**

53快服，添加公司站点，进入53快服云客服后台，

点击“风格设置”-“获取网页代码”

复制“网页资讯代码”到网页后台代码中，即可完成对接。

## **App启动图设置**

打包时 在 manifest.json 选择启动界面配置  选择 Android启动界面设置 选择自定义启动图 设置启动图就可以了

## 设置小程序基本信息有：

包括名称、头像、介绍及服务范围，开发设置中的服务器域名设置

## **微信 接入客服功能** 

参考微信开发者文档给Button添加 show-message-card：true属性 open-type=“content”在微信公众平台接入客服功能，还需要一个微信号，用户点击客服按钮时，就会到这个微信号的聊天框

## **支付宝支付**

首先使用支付宝账号登录开放平台控制台
1.创建应用 创建后填写应用基础信息、添加应用功能和配置环境，会自动生成APPID
2.绑定应用 登录商家中心 在账号中心中的绑定中进行APPID绑定。
3.下载安装密钥工具生成密钥并上传，使用生成密钥请求签名和验签，格式转换、密钥匹配。
5.申请上线应用，审核通过后按照应用类型进行签约
6.随后就可以按照文档进行开发了

## **App调用微信支付**

登录微信开放平台，注册成为微信开放平台开发者。认证开放平台并创建APP                 
提交APP基本信息，通过平台应用审核，获得AppID。提交资料申请微信支付
填写资料等待审核，开户成功之后，进行账户验证
资料审核通过后，完成账户验证。签署协议，获得支付接口，可根据开发文档进行开发

## ***如何发布APP***

1.现在各大平台要注册前都要下载一个开发者平台的账号，首先注册一个账号/密码。

2.阅读一下APP审核标准，然后根据流程上传

3.填写公司的基本信息，以及软件的相关信息，上传ICON，软件截图图片，上传APK软件安装包

 # 十、扩展题

## 1.浏览器渲染机制

网页生成过程：

- `HTML`被HTML解析器解析成`DOM` 树
- `css`则被css解析器解析成`CSSOM `树
- 结合`DOM`树和`CSSOM`树，生成一棵渲染树(`Render Tree`)
- 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成
- 将布局绘制（`paint`）在屏幕上

## 2.深拷贝类型

JSON.perse    JSON.stringify   页面间的传值，如props

## 3.浅拷贝类型

只改变内容

扩展运算符、slice、concat等处理数组的方法

## 4.冒泡算法应用

通过双重for循环，实现排序

## 5.created作用？

最早能请求到data中的数据，和methods的方法

## 6.vue3常用组合API

ref   refs   reactive   

## 7.$route 常用来做什么

传参

## 8.小程序发行流程


1.上传代码
在微信开发者工具的右上角上传处上传全部代码。

勾选不校验合法域名

小程序的接口只支持https。

正式版和体验版上的接口功能实现：将接口地址添加到开发管理——开发设置——服务器域名——request合法域名中

上传的时候设置版本号

2.设为体验版本

3.提交审核
4.发布上线

## 9.路由切换动画

**router-view**

用 `transition` 标签包裹 `router-view` 组件，动态添加动画名，`data` 里定义`transitionName`变量。

```html
<transition :name="transitionName">
  <router-view></router-view>
</transition>
```

.v-enter,.v-leave-to{
            opacity:  0;/*透明度*/
            transform: translateX(150px);
        }
         /*入场(离场)动画的时间段   */
        .v-enter-active,.v-leave-active{
            transition: all 0.8s ease;

## 10.vue3生命周期

1、beforeCreate -> 使用 setup()

2、created -> 使用 setup()

3、beforeMount -> onBeforeMount

4、mounted -> onMounted

5、beforeUpdate -> onBeforeUpdate

6、updated -> onUpdated

7、beforeDestroy -> onBeforeUnmount

8、destroyed -> onUnmounted

9、errorCaptured -> onErrorCaptured

## 11.微信小程序登录流程

wx.login获取code，拿着code跟服务器后台换token，实现登录

## 12.微信小程序中token存在storage中

## 13.微信API地图

wx.getLocation 可以获取当前的地理位置、速度等信息

## 14.箭头函数、普通函数的区别？？？？？？？

一.外形不同
二.箭头函数都是匿名函数
普通函数可以有匿名函数，也可以有具体名函数
三.箭头函数不能用于构造函数，不能使用new
四.箭头函数中this的指向不同，箭头函数没有自己的 this 值。

## 15.递归  需要重复执行的逻辑

就是在运行的过程中调用自己，要设置个出口

## 16.methods和 计算属性

1.两者计算结果都是相同

2.**计算属性是基于他们的依赖的属性**

计算属性只有在与它相关联的依赖发生改变时才会重新调用求值;

**3.methods方法依赖的是页面渲染**

只要页面渲染这个methods方法就会被重新调用

## 17.跨域

首先狭义的同源就是指，域名、协议、端口均为相同。

跨域，是指浏览器不能执行其他网站的脚本。它是由**浏览器的同源策略**造成的，是浏览器对JavaScript实施的安全限制。 

## 18.微信小程序behaviors 

 是**用于组件间代码共享的特性**,类似于一些编程语言中的 “mixins” 

## 19.input框搜索文章，相同的字体变高亮

正则表达式匹配输入框内容，找到父标签节点，添加属性

## 20.浏览器内核？？？？？？？？？？？？

**Trident(IE内核)**

**Gecko(firefox)**

**webkit(Safari)**

**Blink(chrome)**



## 21.ts和js的区别？？	？？？？？？？？

1，ts是静态类语言  js动态
4，ts增加了 void/never/any/元组/枚举/以及一些高级类型
5，js没有重载概念，ts有可以重载
6，vscode/ide对ts有很友好的提示
7，ts更利于重构

## 22.export default 和 exports有什么区别

前者是默认导出，每个模块只能有一个，导入的时候需要用 import XX from‘XXX’这种方式

后者是导出，每个模块可以有多个，导入的时候需要用import {XX} from‘XX’的方式 

## 23. map和set的区别：

Map是键值对，Set是值的集合

Set的值是唯一的可以做[数组去重](https://so.csdn.net/so/search?q=数组去重&spm=1001.2101.3001.7020)，Map可以做数据存储

## 24.作用域和作用域链

作用域：分为全局作用域和局部作用域

作用域链：作用域链是一层作用包裹另一层作用域,从而形成作用域链

## 25.手写轮播图

1.把图片放在一个数组中，定义index，给轮播图父组件定义固定宽高，给可视区设置overflow:hidden，position:absolute，把第一张图片放在最后一张，使用settimeout计时器，每多长时间更改一次，里面设置偏移量和index++，判断index值，当index最大的时候，让index=0，同时改变css样式为left:0

## 26.怎样理解 Vue 的单项数据流

数据总是从父组件传到子组件，子组件没有权利修改父组件传过来的数据，只能请求父组件对原始数据进行修改。这样会防止从子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。

注意：在子组件直接用 v-model 绑定父组件传过来的 props 这样是不规范的写法，开发环境会报警告。

如果实在要改变父组件的 props 值可以再data里面定义一个变量，并用 prop 的值初始化它，之后用$emit 通知父组件去修改。

## 27、Vue事件绑定原理

原生事件绑定是通过 addEventListener 绑定给真实元素的，组件事件绑定是通过Vue自定义的$on实现的。如果要在组件上使用原生事件，需要加.native修饰符，这样就相当于在父组件中把子组件当做普通的HTML标签，然后加上原生事件。
$on、$emit 是基于发布订阅模式的，维护一个事件中心，on的时候将事件按名称存在事件中心里，称之为订阅者，然后emit将对应的事件进行发布，去执行事件中心里的对应的监听器。

## 28、vue-router 动态路由是什么？有什么问题。

我们经常需要把某种模式匹配到的所有路由，全都映射到同个组件。例如，我们有一个 User组件，对于所有 ID 各不相同的用户，都要使用这个组件来渲染。那么，我们可以在 vue-router 的路由路径中使用“动态路径参数”（dynamic segment）来达到这个效果： const User = { 
template: "

User

", };
const router = new VueRouter({
routes: [
// 动态路径参数 以冒号开头
{ path: "/user/:id", component: User },
],
}); 
问题：vue-router 组件复用导致路由参数失效怎么办？
解决方案：
1、通过watch监听路由参数再发请求
watch：{
"router":function(){
this.getData(this.$router.params.xxx)
}
}
2、用 :key来阻止复用
router-view :key="$route.fullPath"

### 29.路由跳转传参 params 和 query 的区别？？？？？？？？

```csharp
1、接收参数的方式不同
    ==>this.$route.params/this.$route.query
2、query的方法传参url路径会显示传递的参数
3、params刷新页面会丢失参数
4、params是用name属性，query是用path属性来编写传参地址
```

### 30.Vue-router 跳转和 location.href 有什么区别

vue-router是路由跳转或同一个页面跳转，进行路由更新，静态跳转，页面不会重新加载；location.href是不同页面间跳转会触发浏览器，页面重新加载一次

```jsx
①vue-router使用pushState进行路由更新，静态跳转，页面不会重新加载；location.href会触发浏览器，页面重新加载一次
②vue-router使用diff算法，实现按需加载，减少dom操作
③vue-router是路由跳转或同一个页面跳转；location.href是不同页面间跳转；
④vue-router是异步加载this.$nextTick(()=>{获取url})；location.href是同步加载
```

### 31.vuex 和 localStorage 的区别？？？？？？？？？

vuex的数据刷新页面会丢失，存储在内存，vuex的数据是响应式的，应用场景：vuex用于组件之间的传值

localstorage，sessionstorage则主要用于不同页面之间的传值，localstorage无法存储function.

```jsx
1、vuex的数据刷新页面会丢失，而localStorage的数据是永久存储的，除非手动清除。
2、vuex存储在内存，localstorage（本地存储）则以文件的方式存储在本地,永久保存；
sessionstorage( 会话存储 ) ,临时保存。localStorage和sessionStorage只能存储字符串类型，
对于复杂的对象可以使用ECMAScript提供的JSON对象的stringify和parse来处理
3、应用场景：vuex用于组件之间的传值，localstorage，sessionstorage则主要用于不同页面之间的传值。
4、vuex的数据是响应式的
5、localstorage无法存储function.
```

### 33.vue 的插槽 v-slot

```xml
父组件需要在子组件内放一些DOM，那么这些DOM是显示、不显示、在哪个地方显示、如何显示，就是slot分发负责的活。
在vue2.6版本以上使用v-slot代替了slot 和 scope-slot ，vue3.0中也弃用了。
v-slot 只能添加到template 或自定义组件上
可以在子组件上写插槽的默认内容：<slot name='header'>11111111111</slot>
1、默认的插槽
    ==>任何没有被包裹在带有 v-slot 的 组件标签 中的内容都会被视为默认插槽的内容。
            没有名字的 隐含有一个 “default” 名称
2、具名插槽
    ==><template v-slot:header> <p>111111111</p> </template>
    ==><template #header> <p>111111111</p> </template>
3、作用域插槽
    ==><slot name="header" :data='user'>0000000000</slot>
    ==><template v-slot:header='slotprops'> <p>{{slotprops.data}}</p></template>
4、动态插槽名
    ==><template v-slot:[dynamicSlotName]> 00000000 </template>
1、父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。
2、<slot></slot>标签里面的内容会作为后备内容且有默认的名字default
3、(特殊：独占默认插槽的缩写语法)---只要出现多个插槽，请始终为所有的插槽使用完整的基于 <template> 的语法，v-slot 只能添加在 <template> 上
4、作用域插槽:绑定在 <slot> 元素上的 attribute 被称为插槽 prop
5、#简写： #default="{ user }"
```

### 34.vue 中的过滤器

```undefined
双花括号插值
1、 当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！
2、 一个表达式可以使用多个过滤器。过滤器之间需要用管道符“|”隔开。其执行顺序从左往右
```

### 35.vue 中的自定义指令

```cpp
directives: 自定义指令
有三个钩子函数
bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。
el, binding, vnode,oldVnode：四个函数的入参
//el：指令所绑定的元素，可以用来直接操作 DOM。
//binding：一个对象，包含以下 property：
//vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。
//oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。
```

### 36.axios 的特点有哪些

```csharp
从浏览器中创建XMLHttpRequests；
node.js创建http请求；
支持Promise API；
拦截请求和响应；
转换请求数据和响应数据；
取消请求；
自动换成json。
axios中的发送字段的参数是data跟params两个，两者的区别在于params是跟请求地址一起发送的，data的作为一个请求体进行发送
params一般适用于get请求，data一般适用于post put 请求。
```

### 37.vue-router 实现路由懒加载

```jsx
结合 Vue 的异步组件 (opens new window)和 Webpack 的代码分割功能 (opens new window)，轻松实现路由组件的懒加载
第一种：vue异步组件技术 ==== 异步加载，vue-router配置路由 , 使用vue的异步组件技术 , 可以实现按需加载 .但是,这种情况下一个组件生成一个js文件。
第二种：路由懒加载(使用import)。
const Index = () => import('@/components/index')
第三种：webpack提供的require.ensure()，vue-router配置路由，使用webpack的require.ensure技术，也可以实现按需加载。这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。
```

### 39. Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？

- Options Api

> 包含一个描述组件选项（data、methods、props等）的对象 options；
> API开发复杂组件，同一个功能逻辑的代码被拆分到不同选项 ；
> 使用mixin重用公用代码，也有问题：命名冲突，数据来源不清晰；

- composition Api

> vue3 新增的一组 api，它是基于函数的 api，可以更灵活的组织组件的逻辑。
> 解决options api在大型项目中，options api不好拆分和重用的问题。


## 40.变量提升

把变量a的声明被提到了作用域顶端

## 41.==和===

判断值，后者判断值+类型

## 42.Vue 的单向数据流

```bash
所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。

这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。

子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。
```

## 43.v-on 可以监听多个方法



```bash
<input type="text" v-on="{ input:onInput,focus:onFocus,blur:onBlur, }">
```

## 44.webpack代码切割

静态代码分割是指：在代码中明确声明需要异步加载的代码。
在 Vue 中，可以直接使用 import() 关键字做到这一点
动态代码分割是指：在代码调用时根据当前的状态，「动态地」异步加载对应的代码块。

## 46uni-app获取应用缓存，缓存清除

 plus.cache.calculate(  ( size ) =>{ *//size是多少个字节单位是b*

判断删除数据

 //可以询问用户是否删除
	uni.showModal({
			title:'提示',
			content:'确定清除缓存吗?',
			success(res) {
			// 用户确定要删除
				if(res.confirm){
				//使用plus.cache.clear 清除应用中的缓存数据 这里清除后还要二十几KB没有清除，达不到全部清除
					plus.cache.clear( function () {
						uni.showToast({
							title:'清除成功',
							icon:'none',
							success() {
								//成功后处理
							}

## 47.有哪些常见的Loader？你用过哪些Loader？

(我开始熟悉的报起了菜名)

`image-loader`：加载并且压缩图片文件

`json-loader`加载 JSON 文件（默认包含）

- `sass-loader`：将SCSS/SASS代码转换成CSS
- `css-loader`：加载 CSS，支持模块化、压缩、文件导入等特性
- `style-loader`：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS

- `babel-loader`：把 ES6 转换成 ES5
- `ts-loader`: 将 TypeScript 转换成 JavaScript







- `raw-loader`：加载文件原始内容（utf-8）

- `file-loader`：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件 (处理图片和字体)

- `url-loader`：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值时返回其 publicPath，小于阈值时返回文件 base64 形式编码 (处理图片和字体)

- `source-map-loader`：加载额外的 Source Map 文件，以方便断点调试

- `svg-inline-loader`：将压缩后的 SVG 内容注入代码中

  

- `handlebars-loader`: 将 Handlebars 模版编译成函数并返回

- 

- `awesome-typescript-loader`：将 TypeScript 转换成 JavaScript，性能优于 ts-loader

- `postcss-loader`：扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀

- `eslint-loader`：通过 ESLint 检查 JavaScript 代码

- `tslint-loader`：通过 TSLint检查 TypeScript 代码

- `mocha-loader`：加载 Mocha 测试用例的代码

- `coverjs-loader`：计算测试的覆盖率

- `vue-loader`：加载 Vue.js 单文件组件

- `i18n-loader`: 国际化

- `cache-loader`: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里



## 48有哪些常见的Plugin？你用过哪些Plugin？

- `ignore-plugin`：忽略部分文件
- `html-webpack-plugin`：简化 HTML 文件创建 (依赖于 html-loader)
- `clean-webpack-plugin`: 目录清理

- `define-plugin`：定义环境变量 (Webpack4 之后指定 mode 会自动配置)
- `web-webpack-plugin`：可方便地为单页应用输出 HTML，比 html-webpack-plugin 好用





- `uglifyjs-webpack-plugin`：不支持 ES6 压缩 (Webpack4 以前)
- `terser-webpack-plugin`: 支持压缩 ES6 (Webpack4)
- `webpack-parallel-uglify-plugin`: 多进程执行代码压缩，提升构建速度
- `mini-css-extract-plugin`: 分离样式文件，CSS 提取为独立文件，支持按需加载 (替代extract-text-webpack-plugin)
- `serviceworker-webpack-plugin`：为网页应用增加离线缓存功能
- 
- `ModuleConcatenationPlugin`: 开启 Scope Hoisting
- `speed-measure-webpack-plugin`: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)
- `webpack-bundle-analyzer`: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)

## 49.那你再说一说Loader和Plugin的区别？

`**Loader`本质就是一个函数，**在该函数中对接收到的内容进行转换，返回转换后的结果。在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。

因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。

`Plugin`就是插件，基于事件流框架`Tapable`，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

在plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

## 50.Webpack构建流程简单说一下，打包流程

- 初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler
- 编译：从 Entry 出发，针对每个 Module 串行调用对应的 Loader 去翻译文件的内容，再找到该 Module 依赖的 Module，递归地进行编译处理
- 输出：将编译后的 Module 组合成 Chunk，将 Chunk 转换成文件，输出到文件系统中

## 51.使用webpack开发时，你用过哪些可以提高效率的插件？

(这道题还蛮注重实际，用户的体验还是要从小抓起的)

- `webpack-dashboard`：可以更友好的展示相关打包信息。
- `webpack-merge`：提取公共配置，减少重复配置代码
- `speed-measure-webpack-plugin`：简称 SMP，分析出 Webpack 打包过程中 Loader 和 Plugin 的耗时，有助于找到构建过程中的性能瓶颈。
- `size-plugin`：监控资源体积变化，尽早发现问题
- `HotModuleReplacementPlugin`：模块热替换

## 52.模块打包原理知道吗？

Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。

## 55.在实际工程中，配置文件上百行乃是常事，如何保证各个loader按照预想方式工作？

可以使用`enforce`强制执行`loader`的作用顺序，`pre`代表在所有正常 loader 之前执行，`post`是所有 loader 之后执行。(inline 官方不推荐使用)

## 56.如何优化 Webpack 的构建速度？

- 使用`高版本`的 Webpack 和 Node.js

- `多进程/多实例构建`：HappyPack(不维护了)、thread-loader `webpack-parallel-uglify-plugin`: 多进程执行代码压缩，提升构建速度

- `压缩代码`：通过 mini-css-extract-plugin 提取 Chunk 中的 CSS 代码到单独文件，通过 css-loader 的 minimize 选项开启 cssnano 压缩 CSS。
  
  - webpack-paralle-uglify-plugin
  - `图片压缩`：配置 image-webpack-loader
  
  提取页面公共资源`：`webpack-merge`插件：提取公共配置，减少重复配置代码
  
  - 使用 html-webpack-externals-plugin，将基础包通过 CDN 引入，不打入 bundle 中
  - 使用 SplitChunksPlugin 进行(公共脚本、基础包、页面公共文件)分离(Webpack4内置) ，替代了 CommonsChunkPlugin 插件

//////////////////////////////////////////////////

- `缩小打包作用域`：
  - exclude/include (确定 loader 规则范围)
  - resolve.modules 指明第三方模块的绝对路径 (减少不必要的查找)
  - resolve.mainFields 只采用 main 字段作为入口文件描述字段 (减少搜索步骤，需要考虑到所有运行时依赖的第三方模块的入口文件描述字段)
  - resolve.extensions 尽可能减少后缀尝试的可能性
  - noParse 对完全不需要解析的库进行忽略 (不去解析但仍会打包到 bundle 中，注意被忽略掉的文件里不应该包含 import、require、define 等模块化语句)
  - IgnorePlugin (完全排除模块)
  - 合理使用alias
- - 
  - 基础包分离：
- `DLL`：
  - 使用 DllPlugin 进行分包，使用 DllReferencePlugin(索引链接) 对 manifest.json 引用，让一些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间。
  - HashedModuleIdsPlugin 可以解决模块数字id问题
- `充分利用缓存提升二次构建速度`：
  - babel-loader 开启缓存
  - terser-webpack-plugin 开启缓存
  - 使用 cache-loader 或者 hard-source-webpack-plugin
- `Tree shaking`
  - purgecss-webpack-plugin 和 mini-css-extract-plugin配合使用(建议)
  - 打包过程中检测工程中没有引用过的模块并进行标记，在资源压缩时将它们从最终的bundle中去掉(只能对ES6 Modlue生效) 开发中尽可能使用ES6 Module的模块，提高tree shaking效率
  - 禁用 babel-loader 的模块依赖解析，否则 Webpack 接收到的就都是转换过的 CommonJS 形式的模块，无法进行 tree-shaking
  - 使用 PurifyCSS(不在维护) 或者 uncss 去除无用 CSS 代码
- `Scope hoisting`
  - 构建后的代码会存在大量闭包，造成体积增大，运行代码时创建的函数作用域变多，内存开销变大。Scope hoisting 将所有模块的代码按照引用顺序放在一个函数作用域里，然后适当的重命名一些变量以防止变量名冲突
  - 必须是ES6的语法，因为有很多第三方库仍采用 CommonJS 语法，为了充分发挥 Scope hoisting 的作用，需要配置 mainFields 对第三方模块优先采用 jsnext:main 中指向的ES6模块化语法
- `动态Polyfill`
  - 建议采用 polyfill-service 只给用户返回需要的polyfill，社区维护。(部分国内奇葩浏览器UA可能无法识别，但可以降级返回所需全部polyfill)

更多优化请参考官网-构建性能

## 59、[Vue](https://so.csdn.net/so/search?q=Vue&spm=1001.2101.3001.7020) 3.0 性能提升主要是通过哪几方面体现的？

### 1. 响应式系统提升

- vue2在初始化的时候，对data中的每个属性使用definepropery调用getter和setter使之变为响应式对象。如果属性值为对象，还会递归调用defineproperty使之变为响应式对象。
- vue3使用proxy对象重写响应式。proxy的性能本来比defineproperty好，proxy可以拦截属性的访问、赋值、删除等操作，不需要初始化的时候遍历所有属性，另外有多层属性嵌套的话，只有访问某个属性的时候，才会递归处理下一级的属性。

优势：
可以监听动态新增的属性；
可以监听删除的属性 ；
可以监听数组的索引和 length 属性；

### 2. 编译优化

- 优化编译和[重写](https://so.csdn.net/so/search?q=重写&spm=1001.2101.3001.7020)虚拟dom，让首次渲染和更新dom性能有更大的提升
  vue2 通过标记静态根节点,优化 diff 算法
  vue3 标记和提升所有静态根节点,diff 的时候只比较动态节点内容
- Fragments, 模板里面不用创建唯一根节点,可以直接放同级标签和文本内容
- 静态提升
- patch flag, 跳过静态节点,直接对比动态节点
- 缓存事件处理函数

### 3. 源码体积的优化

- vue3移除了一些不常用的api，例如：inline-template、filter等
- 使用tree-shaking

## 60. Vue.js 3.0 响应式系统的实现原理？

### 1. reactive

设置对象为响应式对象。接收一个参数，判断这参数是否是对象。不是对象则直接返回这个参数，不做响应式处理。
创建拦截器handerler，设置get/set/deleteproperty。
**get**
收集依赖（track）；
如果当前 key 的值是对象，则为当前 key 的对象创建拦截器 handler, 设置 get/set/deleteProperty；
如果当前的 key 的值不是对象，则返回当前 key 的值。
**set**
设置的新值和老值不相等时，更新为新值，并触发更新（trigger）。
**deleteProperty**
当前对象有这个 key 的时候，删除这个 key 并触发更新（trigger）。

### 2. effect

接收一个函数作为参数。作用是：访问响应式对象属性时去收集依赖

### 3. track

接收两个参数：target 和 key
－如果没有 activeEffect，则说明没有创建 effect 依赖
－如果有 activeEffect，则去判断 WeakMap 集合中是否有 target 属性
－WeakMap 集合中没有 target 属性，则 set(target, (depsMap = new Map()))
－WeakMap 集合中有 target 属性，则判断 target 属性的 map 值的 depsMap 中是否有 key 属性
－depsMap 中没有 key 属性，则 set(key, (dep = new Set()))
－depsMap 中有 key 属性，则添加这个 activeEffect

### ４.trigger

判断 WeakMap 中是否有 target 属性，WeakMap 中有 target 属性，则判断 target 属性的 map 值中是否有 key 属性，有的话循环触发收集的 effect()。

## 62网络七层模型

![img](https://img-blog.csdn.net/20160923175430340)

## 63.HTTP 3.0 2.0 1.1 1.0区别???????

`HTTP1.0

无状态、无连接
HTTP1.1

支持长连接，请求管道化（请求并行发送，相应仍然需有序返回）
增加缓存处理（新的字段如cache-control）
增加Host字段，适应虚拟主机技术发展，即一台服务器支持多台主机
支持断点传输
HTTP2.0

二进制分帧
多路复用（或连接共享）
头部压缩，encoder
服务器推送

`HTTP/3`应该在操作系统底层支持，是内核的一个功能，系统提供接口给应用层使用，不然写个简单的应用要考虑通讯方面的细节，或者引用一个庞大的`HTTP/3`类库，感觉有点得不偿失。我们也可以换个思路综合`UDP`无链接以及`TCP`可靠传输的特点开发一个新的传输层协议，而不是将通讯问题抛给应用层。

## 65Git分支创建命令

<name> : 分支名

查看分支：git branch

功能	命令
创建分支	git branch <name>
切换分支	git checkout <name>
创建+切换分支	git checkout -b <name>
合并某分支到当前分支	git merge <name>
删除分支	git branch -d <name>
查看分支	git branch
查看远程分支	git branch -a
查看当前分支最后一次修改的信息	git show
查看当前分支最后一次修改信息简化版	git show --stat

## 66post的头部

1.第一种：application/json： {“key1":"xxx",“key2":“xxxx",“key3":false}  2.第二种：application/x-www-form-urlencoded： key1 =xxx&key2=ooo&key3=false  3.第三种：multipart/form-data:这一种是表单格式的 <methodname>examples.getStateName</methodname> 5.还有文件下载的时候 Content-Type: octets/stream

## 67.es6暂时性死区

在es6中，代码块内，使用let/const声明之前，该变量都是不可用的，在变量声明之前属于该变量的“死区”、在语法上，称之为“暂时性死区”也叫临时性死区

## 68.浏览器怎么做兼容

IE浏览器一般使用css hack方式来解决，即在代码前面加上* 、_、 +等符号
谷歌一般在属性前面加上-webkit-来进行兼容
火狐一般在属性前面加上-moz-进行兼容
webpack使用postcss给css属性自动添加前缀，进行兼容

安装postcss-loader和postcss-preset-env
配置webpack.config.js
在package.json中配置browserslist
选择process.env.NODE_ENV

## 72.promise里的all和race区别

1.**Promise**. **all** ()会在多个 promise 全部resolve之后执行.then，结果有一个为false就输出false

2.**Promise**. **race** ()会在任何一个 promise resolve后就会执行.then，执行结果为true就返回true，执行结果为false就返回false

## 73.模块化   node模块化、ES6模块化区别

CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。

ES6模块化在浏览器和node.js中都可以用。
node模块使用require()和module.exports，ES6 模块使用import和export。

node 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。
node模块是运行时加载，ES6 模块是编译时输出接口。
node模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段。

## 74.async await 捕获异常

使用try catch

## 75.settimeout  async await  setinterval区别

[setInterval](https://so.csdn.net/so/search?q=setInterval&spm=1001.2101.3001.7020)：表示多久执行一次，需要clearInterval(timer)来让它停下
[setTimeout](https://so.csdn.net/so/search?q=setTimeout&spm=1001.2101.3001.7020)：表示过了多久之后执行，只会执行一次！

async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，**等到触发的异步操作完成**

微任务 promise 本身是同步的立即执行函数

**setTimeout会在async/await之后再执行。但promise的内容会在async/await之前执行。**

微任务 > 宏任务

```text
宏任务
script(整体代码)
setTimeout
setInterval
I/O
UI交互事件
postMessage
MessageChannel
setImmediate(Node.js 环境)
```

```text
微任务
Promise.then
Object.observe
MutationObserver
process.nextTick(Node.js 环境)
```

## 76.上传文件、图片？？？？

```js

<button>上传</button>

</body>
<script src=" ./jquery.js"></script>
<script>
//---------使用上传文件必须将文件对象存放在formData实例中上传给后端
let formdata = new FormData( ) ;
//------------向formdata对 象中添加属性append(添加成功后看不见)
// formdata. append("name" , "张三")
// console. log(formdata)
$(" input") . change( function(e){
console.log(e)
//获取文件信息
1et file = e.target.files[0];
console.log(file )
formdata. append("photo" ,file)
}
$( "button").click( function(){
$.({
url:"//file" ,
method : "post" ,
//参数为formdata实例
data: formdata,
// headers:{
// "Content- Type" : "multipart/ form-data"
// },
----------// 默认会处理上传的文件信息,
--------//不允许处理请求信息
------------processData:false,
--------------contentType:false,
success(res){
console. log(res )
}
})
};
</script>
```

## 77.如何定义一个包？？？？？？？？？？？

## 78.vuex传参

 this.$store.commit('increment',5);

页面刷新vuex中数据丢失

## 81.formdata如何追加东西

可以先通过new关键字创建一个空的 FormData 对象，然后使用 **append () 方法向该对象里添加字段**（字段的值可以是一个 Blob 对象，File对象或者字符串，剩下其他类型的值都会被自动转换成字符串）。

## 83.target 和current Target 区别

 target:触发事件的元素。currentTarget:事件绑定的元素。 

## 84.bind为何要手动调用返回一个新函数，如何调用

## 85数组小写变大写map（）

## 86.es5继承和es6继承区别

- ES5的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到this上（Parent.apply(this)）.
- ES6的继承机制完全不同，实质上是先创建父类的实例对象this（所以必须先调用父类的super()方法），然后再用子类的构造函数修改this。
- ES5的继承是通过原型或构造函数机制来实现。
- ES6通过class关键字定义类

## 87.TCP三次握手四次挥手

第一次握手是在**建立连接**，客户端发送连接请求报文段，把标有SYN的数据包发给服务器端即为接收端。

第二次握手是**服务器端即接收端收到客户端的SYN的报文段**，同时发送标有SYN/ACK的数据包。

第三次握手是**客户端收到服务器端的SYN/ACK的数据包后**，向服务器端发送标有ACK的数据包。




## 88.斐波那契又称黄金分割

思路：理解Fn=F(n-1)+F(n-2)（n>=2，n∈N*）并运用。
换成[Python](https://so.csdn.net/so/search?q=Python&spm=1001.2101.3001.7020)语言就是F(n-1)，F(n-2)=F(n-2)，F(n-1)+F(n-2)
1.这个数列从第三项开始，每一项都等于前两项之和。2.从第二项开始，每个奇数项的平方都比前后两项之积多1，每个偶数项的平方都比前后两项之积少1，奇数项和偶数项是指项数的奇偶。

## 89.mixin规则

数据 data
数据对象在混入时，会进行合并，发生冲突是，保留组件的数据

值为对象 methods computed等
在混入时，同名的methods会合并成为一个对象
如果对象的键名发生冲突，则保留组件对象的键值对


## 90.路由里命名视图

就是可以在页面中定义多个单独命名的视图，比如：导航，侧边栏，主体等。

## 95. null==undefiund?空 === false

## 96.一次性更新多条setdata的数据方法

一维变二维

“一维数组和二维数组区别：*单行或单列的数组，称为一维数组，多行多列（含2行2列）的数组是二维数组。*

## 97.dom操作

// 查询父标签parent()

.parent()

// 查询所有的父节点 可以根据条件查询

.parents("body")

.parentsUntil()

// 查询子标签 children

.children()

// 查询满足条件的子标签 参数为 标签选择器

.find()

// 查询兄弟标签 查询除自己之外所有的亲兄弟标签

.siblings()

// 查询下一个兄弟标签

.next()

.nextAll())

//查询上面的兄弟标签

.prev()

.prevAll()

## 49、用户行为预测？

通过检测用户行为信息，收集用户喜好，判断用户下一步可能会点击那个页面，对该页面进行预渲染或者缓存

如何预测？后端负责写收集用户行为的代码，封装成接口，石墨文档给前端，前端根据产品经理需求，按需将接口放到需要的地方，比如用户刚登陆APP时的page中，相当于埋点

数据采集，比如用户喜好记录，小程序崩溃出现的问题记录

## 98.svn和git的区别

git属于分布式控制系统,SVN属于集中式控制系统

## 99.闭包，防抖，节流使用

定义一个函数里面又套一个函数，settimeout进行调用，传参使用防抖节流

## 100axios封装

安装引入，设置地址，请求时间，请求头拦截

## 106.js特点

1.简单性 　JavaScript是一种脚本编写语言，它采用小程序段的方式实现编程，JavaScript同样是一种解释性语言，它提供了一个简易的开发过程。它与HTML标识结合在一起，从而方便用户的使用操作。

 2.动态性　 JavaScript是动态的，它可以直接对用户或客户输入做出响应，无须经过Web服务程序

 3.跨平台性 　JavaScript是依赖于浏览器本身，与操作环境无关，只要能运行浏览器的计算机，并支持JavaScript的浏览器就可以正确执行。



## 107.h5支付

- [getChannels](https://www.html5plus.org/doc/zh_cn/payment.html#plus.payment.getChannels): 获取支付通道

- [request](https://www.html5plus.org/doc/zh_cn/payment.html#plus.payment.request): 请求支付操作

  参数：

- channel:

  ( [PaymentChannel](https://www.html5plus.org/doc/zh_cn/payment.html#plus.payment.PaymentChannel) ) 必选 

  指定支付操作的通道，通过getChannels接口获取。

- statement:

  ( String | JSON | [OrderStatementIAP](https://www.html5plus.org/doc/zh_cn/payment.html#plus.payment.OrderStatementIAP) ) 必选 

  支付订单信息，由支付通道定义的数据格式，通常是由业务服务器生成或向支付服务器获取，是经过加密的字符串信息。

- successCB: 

  ( [PaymentSuccessCallback](https://www.html5plus.org/doc/zh_cn/payment.html#plus.payment.PaymentSuccessCallback) | [IapPaymentSuccessCallback](https://www.html5plus.org/doc/zh_cn/payment.html#plus.payment.IapPaymentSuccessCallback) ) 可选 

  请求支付成功回调函数

- errorCB: 

  ( [PaymentErrorCallback](https://www.html5plus.org/doc/zh_cn/payment.html#plus.payment.PaymentErrorCallback) ) 可选 

  请求支付失败回调函数


/////////////////////////////////////////////////////////////////

### 109、CSS特性：继承性，层叠，优先级

1、继承性：子标签会继承父标签的某些样式，如文本颜色和字号。(text- font- color)

2、层叠性：样式冲突，遵循的原则是就近原则。

3、优先级：定义CSS样式时，经常出现两个或更多规则应用在同一元素上，此时，谁的权重高显示谁的样式。

（选择器相同，则执行层叠性；选择器不同，就会出现优先级的问题。）

     !Important > 行内式 > id > 类/伪类/属性 > 标签选择器  >  全局
    （对应权重：无穷大∞>1000>100>10>1>0）
### 110、五种定位

relative(相对定位):

static: 默认值 没有定位

absolute（绝对定位):生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位

fixed（固定定位）:生成绝对定位的元素，相对于浏览器窗口进行定位

sticky 粘性定位 当前元素设置了粘性定位，滚动到顶部就会吸附顶部，往下滑还回到原来位置。

z-index规则

1、值可以是正整数、负整数或0，数值越大，盒子越靠上；

2、如果属性值相同，则按照书写顺序，后来居上；

3、数字后面不能加单位。

4、z-index 只能应用于相对定位、绝对定位和固定定位的元素，其他标准流、浮动和静态定位无效

### 113、上下margin重合的问题

1、相邻块元素垂直外边距的合并

解决方案：尽量给只给一个盒子添加margin值

2、嵌套块元素垂直外边距的合并（塌陷）

解决方案：

可以为父元素定义上边框。

可以为父元素定义上内边距

可以为父元素添加overflow:hidden。

### 116、Html5新增的语义化标签。

头部标签：<header></header>

导航标签：<nav></nav>

内容区块表签：<section></section>

页脚标签：<footer></footer>

侧边栏：<aside></aside>

页面内独立的内容区域：<article></article>

### 133、元素的alt和title有什么异同

不同点: 元素的alt是表示图片加载失败显示的文本内容，而title是表示鼠标悬停图片时显示的文本内容.

相同点: 在alt和title同时设置的时候，alt作为图片的替代文字出现，title是图片的解释文字

### 36、元素居中的方式、以及垂直上下居中

方法一：给父元素设置成弹性盒子，子元素横向居中，纵向居中

方法二：父相子绝后，子部分向上移动本身宽度和高度的一半，也可以用transfrom:translate(-50%,-50%)（最常用方法）

方法三：父相子绝，子元素所有定位为0，margin设置auto自适应



### 137三栏布局、圣杯布局、双飞翼布局

圣杯布局和双飞翼布局是前端工程师需要日常掌握的重要布局方式。两者的功能相同，都是为了实现一个两侧宽度固定，中间宽度自适应的三栏布局。（中间先加载渲染）

1. 首先要给两侧设置padding预留出相应的空间

2. 随后分别为三列设置宽度与浮动，同时对footer设置清除浮动

3. 根据浮动的特性，由于center的宽度为100%，即占据了第一行的所有空间，所以left和right被“挤”到了第二行。

4. 接下来的工作是将left放置到之前预留出的位置上，这里使用负外边距

5. 这里使用position: relative和right: 200px将left的位置在原有位置基础上左移200px，以完成left的放置

### 139、常见的块级、行级、空元素

在CSS中规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，比如div默认display属性值为“block”，成为“块级”元素；span默认display属性值为“inline”，是“行内”元素。

我们在平常的项目中经常使用到的有

· 行内元素有：span a b i img input select strong

· 块级元素有：div p h1-h6 ul table form ul ol li dl dt dd…

· 空元素(没有内容)： <hr> <img> <input> <link> <meta>

### 141字符串的方法

```
2、concat( )：返回新的字符串**，将一个或多个字符串与原字符串连接合并
3、indexOf( )：检索字符串，返回第一次出现的索引，没有出现则为-1
4、lastIndexOf(searchValue[ fromIndex]) 返回从字符串尾部开始第一次出现的索引，没有则-1，fromIndex的值相对于从尾部开始的索引
5、split( )：返回一个以指定分隔符出现位置分隔而成的一个数组，数组元素不包含分隔符
6、substr( )：从起始索引号提取字符串中指定数目的字符；
7、substring( )：提取字符串中两个指定的索引号之间的字符；
10、valueOf( )：返回某个字符串对象的原始值； 
11、trim( )：删除字符串两边的空格；
12、trimeState 取出开始的空格
13、trimeEnd  去除末尾空格
14、includes(searchString[, position])返回boolean，判断一个字符串是否包含在另一个字符串中，从postition索引开始搜寻，默认0
15、slice( )：提取字符串片段，并在新的字符串中返回被提取的部分；
16、search(regexp)返回首次匹配到的索引，没有则-1，执行正则表达式和 String 对象之间的一个搜索匹配
17、toString()返回一个表示调用对象的字符串，该方法返回指定对象的字符串形式
19、replace() 把指定的字符串替换成为别的字符
```

### 142数组的方法

1、sort( )：sort 排序 如果下面参数的正反 控制 升序和降序 ，返回的是从新排序的原数组
2、splice( )：向数组的指定index处插入 返回的是被删除掉的元素的集合，会改变原有数组；截取类 没有参数，返回空数组，原数组不变；一个参数，从该参数表示的索引位开始截取，直至数组结束，返回截取的 数组，原数组改变；两个参数，第一个参数表示开始截取的索引位，第二个参数表示截取的长度，返回截取的 数组，原数组改变；三个或者更多参数，第三个及以后的参数表示要从截取位插入的值。会改变原数据
3、pop( )：从尾部删除一个元素 返回被删除掉的元素，改变原有数组。
4、push( )：向数组的末尾追加 返回值是添加数据后数组的新长度，改变原有数组。
5、unshift( )：向数组的开头添加 返回值是添加数据后数组的新长度，改变原有数组。
6、shift( )：从头部删除一个元素 返回被删除掉的元素，改变原有数组。
7、reverse( )： 原数组倒序  它的返回值是倒序之后的原数组
8、concat( )：数组合并。
9、slice( )：数组元素的截取，返回一个新数组，新数组是截取的元素，可以为负值。从数组中截取，如果不传参，会返回原数组。如果只传入一个参数，会从头部开始删除，直到数组结束，原数组不会改变；传入两个参数，第一个是开始截取的索引，第二个是结束截取的索引，不包含结束截取的这一项，原数组不会改变。最多可以接受两个参数。
10、join( )：讲数组进行分割成为字符串  这能分割一层在套一层就分隔不了了
11、toString( )：数组转字符串；
12、toLocaleString( )：将数组转换为本地数组。
13、forEach( )：数组进行遍历；

14、map( )：没有return时，对数组的遍历。有return时，返回一个新数组，该新数组的元素是经过过滤(逻辑处理)过的函数。

15、filter( )：对数组中的每一运行给定的函数，会返回满足该函数的项组成的数组。
16、every( )：当数组中每一个元素在callback上被返回true时就返回true。（注：every其实类似filter，只不过它的功能是判断是不是数组中的所有元素都符合条件，并且返回的是布尔值）。
17、some( )：当数组中有一个元素在callback上被返回true时就返回true。（注：every其实类似filter，只不过它的功能是判断是不是数组中的所有元素都符合条件，并且返回的是布尔值）。
19.isArray() 判断是否是数组

20. indexOf  找索如果找到了就会返回当前的一个下标，若果没找到就会反回-1
21. lastIndexOf 它是从最后一个值向前查找的 找索如果找到了就会返回当前的一个下标，若果没找到就会反回-1
22. Array.of() 填充单个值
23. Array.from() 来源是类数组    
23. 24.fill填充方法 可以传入3各参数 可以填充数组里的值也就是替换 如果一个值全部都替换掉 ，    第一个参数就是值 第二个参数 从起始第几个 第三个参数就是最后一个
find  查找这一组数 符合条件的第一个数 给他返回出来
findIndex() 查找这一组数 符合条件的第一数的下标 给他返回出来     没有返回 -1  
keys 属性名  values属性值  entries属性和属性值
forEach 循环便利 有3个参数 无法使用 break continue ， 参数一就是每个元素 参数二就是每个下标 参数三就是每个一项包扩下标和元素

## 146、this指向的问题（高频）

```
在全局的环境下this是指向window 的

普通函数调用直接调用中的this 会指向 window， 严格模式下this会指向 undefined，自执行函数 this 指向 window，定时器中的 this 指向 window

在对象里调用的this，指向调用函数的那个对象，

所以构造函数中的 this 指向 当前实例化的对象/new出来的新对象

方法中的this谁调用就指向谁。

箭头函数没有自己的 this，箭头函数的this在定义的时候，会继承自外层第一个普通函数的thi
```

## map和foreach区别

1.只能遍历数组

forEach()不会返回执行结果而是undefined 会修改原来的数组

map 过滤得到新的数组

## vue2传参

```js
父传子：props
/*
1.在父组件中的子组件标签上自定义一个属性
2.在子组件中使用props来接收传过来的数据可直接使用 
若想要在setup接口函数中使用，则需要setup形参props中获取
*/

子传父
/*
//context.emit发送自定义事件 参数一自定义接方事件名称 参数二传递参数
context.emit('send', num.value);
}
1.在子组件中使用 setup入口函数的形参context 发送一个自定义事件 context.emit("自定义事件名称",'传递的参数')
2.在父组件中的子组件上绑定自定义事件
3.在事件函数参数中获取传递过来的数据
*/

非父子：
/*
在vue3.x版本中，非父子组件之间的传值需要借助第三方模块儿mitt来实现
\1. 使用npm 安装mitt 模块儿
\2. 创建一个bus.js文件用来初始化mitt;
\3. 在哪个组件中使用就在那个组件引入
\4. 使用bus.emit发送自定义事件传参     使用bus.on监听自定义事件 获取参数
```

## 响应式数据

引入组合API  ref  reactive

import {ref,reactive} from 'vue'

数组，num，等用ref

使用ref声明的响应式必须通过.value来更改其值

对象用reactive没有value属性，可直接改变

响应式数据必须return出去

## 浏览器如何下载文件

常规的 <a> 标签通过 href 实现链接跳转，如果只想下载文件而不是跳转预览，最好的方式是在 <a> 标签中添加 download 属性

 download 是 HTML5 中 <a> 标签新增的一个属性，此属性会强制触发下载操作，指示浏览器下载 URL 而不是导航到它，并提示用户将其保存为本地文件，例如： 如果缺少 download 属性，点击 "download" 会直接变成预览图片，当添加 download 属性后则会触发图片的下载

# 构造函数和普通函数的区别

1、构造函数也是一个普通函数，创建方式与普通函数一样（构造函数习惯上首字母大写)。

2、调用方式不一样。

作用也不一样（构造函数用来新建实例对象）

3、调用方式不一样

a. 普通函数的调用方式：

直接调用 child();

b.构造函数的调用方式：

需要使用new关键字来调用 new Child();

## 首屏性能优化你是怎么做的

## 浏览器的性能监控你是怎么做的

## 虚拟列表你是怎么实现的

## 说一下你项目的难点和你在项目中承担的角色 ，你觉的你在团队里是一个什么样的角色

## 说一下多页面的状态管理

