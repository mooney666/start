# 北游国际面试题总结

> 人事部分
>
> html、css
>
> javascript
>
> 网络请求

# 一、人事部分

- 参考网址

  https://juejin.cn/post/7010948744560508941

- 自我介绍

  **模板一:**

  你好，我叫 XXX,有 XX 年工作经验，来应聘前端开发工程师这一岗位。我之前在 XXX 工作过，期间主要负责前端项目、app 和微信小程序的开发和维护工作。参与开发的项目有 XX 个，独自开发的项目的有 XX 个。在此期间，商城/交友/工具/直播/类项目做的比较多。其中印象最深的是 XX 项目，因为是第一个独立开发的项目/学到知识最多的项目/最难的项目/最近才做好的项目/开发周期最长的项目。我在招聘网上看到咱们公司的招聘信息，感觉自身跟公司比较契合，希望能够加入公司，成为公司的一员。

  **模板二:**

  **注意：语速不能过慢不能过快，不要边想边说，一定是把自我介绍想好，一般人的语速是在 80-160 之间**

- 公司有几个人，部门构成是什么，你所属哪个部门，有几个人

  甲方 掏钱 18000
  --IT 劳务外派公司 15000 - 3000
  乙方 -- 外包公司
  12 个人
  人事部 1
  财务部 1
  技术部 7 1 个 UI1 个 后端 2（后端的某一个人员） 前端 2 1 个 ios/ 1android
  市场部 4 2 个 4 个项目 _ 2-8w = 20w
  15% _ 50 = 7.5w
  UI 5k+14k+14K + 8k = 4.1

  政府 -- 人脉

  产品经理、UI、后端、前端、CTO（技术总监）
  根据客户需求 -> 墨刀 -> 原型图
  UI : 设计图、切。。。
  后端: java、PHP、Python、Ruby、Golang
  前端: 页面

- .为什么离职

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cde680055554c689d970df11b969dc9~tplv-k3u1fbpfcp-watermark.awebp)

# 二、html 部分

## 2.1 HTMl5 新增特性有哪些？

(1) 新增了语义化标签

(2) 新增了音频（audio）视频（video）标签

(3) 新增了 canvas 和 svg 绘图

(4) 新增了地理定位（navigator.geolocation）

(5) 新增了拖拽 API (drapable)

(6) 新增了多线程技术 web worker

(7) 新增了即时通讯 web socket

## 2.2 CSS3 新增特性

(1) 增加了 transition 渐变 animation 动画

(2) 选择器、阴影、弹性布局 flex

(3) 媒体查询等

## 2.3 W3C 标准有哪些？（可以不会）

(1) 标准分为三个层面，结构(html)、行为(js)、表现(css)

(2) 标准有:

(3) 文档类型需要声明（!DOCTYPE）

(4) 编码格式需要声明 <meta charset=”utf-8”>

(5) javascript 代码需要定义

(6) <script language=”javascript” type = ”text/javascript”></script>

(7) css 代码需要定义

(8) <style type=”text/css”></style>

(9) 标签名字和标签内部属性名字小写等

## 2.4 你遇到哪些浏览器兼容问题？您怎么处理浏览器兼容性问题的

参考地址: https://www.cnblogs.com/wxf-h/p/10513342.html

[浏览器兼容性问题](https://blog.csdn.net/Xiaocong__/article/details/122456782)

- **css 兼容性问题**

  1. cursor:hand VS cursor:pointer

  ```
  firefox 不支持hand，但ie支持 pointer
  解决方法:统一使用pointer
  ```

  2. innerText 在 IE 中能正常工作，但在 FireFox 中却不行
  3. CSS 透明
  4. 盒子模型
  5. 块属性标签 float 后，又有横行的 margin 情况下，在 IE6 显示 margin 比设置的大
  6. 图片默认有间距
  7. 万能清除浮动
  8. IE 捉迷藏的问题
  9. 溢出显示省略号
  10. IE6 下图片下有空隙产生
  11. 超链接访问过后 hover 样式就不出现的问题

- **JS 里面的兼容性问题**
  1.const 问题
  说明:Firefox 下,可以使用 const 关键字或 var 关键字来定义常量;IE 下,只能使用 var 关键字来定义常量.

  ​ **解决方法：统一使用 var 关键字来定义常量.**
  2.event.srcElement 问题
  ​ 说明：IE 下，event 对象有 srcElement 属性，但是没有 target 属性；Firefox 下，even 对象有 target 属性，但是没有 srcElement 属性。
  ​ **解决方法：使用 srcObj =event.srcElement ?event.srcElement : event.target;** 3.事件绑定
  IE：dom.attachEvent();
  其他浏览器：dom.addEventListener();
  标准浏览器采用事件捕获的方式对应 IE 的事件冒泡机制（即标准由最外元素至最内元素或者 IE 由最内元素到 最外元素）最后标准方亦觉得 IE 这方面的比较合理，所以便将事件冒泡纳入了标准，这也 addEventListener 第三个参数的由来，而且事件冒泡作为了默认值。 4. ajax 略有不同
  IE:ActiveXObject
  其他：xmlHttpReuest

## 2.5 CSS 伪类选择器有哪些?（会一点就行了）

(1) :before 在...之前

(2) :after 在...之后

(3) :active 点击

(4) :hover 鼠标悬停

(5) :first-letter 所有文字当中的第一个

(6) :first-line 所选元素当中的第一行

(7) :first-child 第一个子元素

(8) :nth-child() 获取子元素

(9) :nth-of-type 获取指定类型的子元素

等等几十个

## 2.6 常用的适配手段有哪些

1.媒体查询

2.弹性布局

3.使用各种 UI 框架，UI 框架一般都做了适配工作

4.手淘适配方案 （使用 flexiable 插件完成适配）

## 2.7 说说你对 flex 布局的理解

参考: https://www.cnblogs.com/jpwz/p/12483053.html
Flex 是 Flexible Box 的缩写，意为"灵活的盒子"或"弹性的盒子"，所以 flex 布局一般也叫作"弹性布局"。

- display 属性
- flex-direction 属性
- flex-wrap 属性
- flex-flow
- justify-content 属性
- align-items 属性
- align-content 属性

## 2.8 rem 和 em、VH、VW、PX 的区别

em 是相对于父级标签的字体大小来定义的
rem 是相对于 html 标签的字体大小来定义的

## 2.9 canvas 和 svg 的区别

都可以用来绘制图形，但是 canvas 是基于 js 来绘制的，svg 是基于 xml 来绘制的.SVG 绘制出来的是矢量图。

## 2.10 什么是 BFC？BFC 的布局规则是什么？如何创建 BFC？BFC 应用？

`BFC` 是 `Block Formatting Context `的缩写，即块格式化上下文。`BFC`是 CSS 布局的一个概念，是一个环境，里面的元素不会影响外面的元素。 布局规则：Box 是 CSS 布局的对象和基本单位，页面是由若干个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。不同类型的 Box 会参与不同的`Formatting Context`。

创建：浮动元素 `display：inline-block position:absolute`

应用: 1.分属于不同的`BFC`时,可以防止`margin`重叠 2.清除内部浮动 3.自适应多栏布局

## 2.11 BFC 的作用

(1)避免 margin 重叠
(2)清除浮动

## 2.12 清除浮动的方式有哪些

(1)浮动元素后新增标签，并且设置属性 clear:both ;
(2)浮动元素的父标签设置属性 overflow:hidden;
(3)设置伪类选择器 XX:after{clear:both}

## 2.13 网站页面常见优化的手段

(1)优化图片资源的格式（优先级选择 webp > jpeg > png > bmp）
(2)使用压缩文件 min.js、min.css
(3)使用浏览器缓存（cookie ， localStorage）
(4)尽量减少请求次数
(5)使用懒加载，避免一次性请求过多

## 2.14 常见的浏览器内核有哪些

![常见的浏览器内核](https://img0.baidu.com/it/u=2675011306,1630146604&fm=253&fmt=auto&app=138&f=PNG?w=884&h=398)

> - 1、IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；
> - 2、Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink 内核；
> - 3、Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；
> - 4、Safari 浏览器内核：Webkit 内核；
> - 5、Opera 浏览器内核：最初是自己的 Presto 内核，后来是 Webkit，现在是 Blink 内核；

## 2.15 CSS 选择器优先级

- 内联样式表的权值为 1000

- ID 选择器的权值为 100

- Class 类选择器的权值为 10

- HTML 标签选择器的权值为 1

  通过使用加法计算出来权重的大小

## 2.16 左右两边固定宽度 （左边固定右边自适应布局）中间自适应 布局实现

圣杯布局、双飞翼布局

左边固定右边自适应 七种方式

https://segmentfault.com/a/1190000010698609

## 2.17 九宫格实现方式

- flex 布局 （css3）
- grid 布局 （css3 新增）
- float
- table （）

参考地址：https://www.cnblogs.com/sunshq/p/10118425.html

## 2.18 让一个盒子在父元素的中进行左右垂直居中

参考地址： https://www.cnblogs.com/yingtoumao/p/11541256.html

## 2.19 什么是盒子模型？

(按照自己的话描述即可)
w3c 标准盒模型：盒子的宽度=width（content）+左右内边距+左右边框
盒子所占的空间=盒子宽度+左右外边距
怪异盒模型：盒子的宽度=width=content+左右内边距+左右边框
盒子所占的空间=盒子宽度+左右外边距
Content-box:标准盒模型
Border-box：怪异盒模型
w3c 转怪异 box-sizing:border-box; 也可以通过 值为 content-box 转回来

## 2.20 简述字体图标的原理，动手实现使用 iconfont 实现字体图标的 demo。

/_ 定义 font-family _/
@font-face {
font-family: "myiconfont";
src: url('./iconfont.woff2') format('woff2'),
url('./iconfont.woff') format('woff'),
url('./iconfont.ttf') format('truetype'),
url('./iconfont.svg#iconfont') format('svg');
}
/_ 以“iconfont”开头的 包含“ iconfont”的 class 的值，都是下面的样式 ------属性选择符_/
[class^="iconfont"],
[class*=" iconfont"] {
font-family: "myiconfont!important";
font-style: normal;
font-size: 14px;
}
也可以
.iconfont{
font-family: "myiconfont!important";
font-style: normal;
font-size: 14px;
}
/_在类名为 icon-star 这个元素内容的前面插入一个文字图标
此编码在 生成图标时就有的
_/
.icon-star::before {
content: "\e616";
}
<span class="iconfont icon-star"></span>
<span class="icon-star iconfont"></span>

注意：得有字体 iconfont.woff2 iconfont.woff iconfont.ttf
iconfont.svg ,如果哪个不存在的话 url（）可以去掉的，主要考虑兼容性才写这几种类型的，其实是同一个图标

## 2.21 浏览器渲染机制、重绘、重排

![浏览器渲染机制](https://static.vue-js.com/2b56a950-9cdc-11eb-ab90-d9ae814b240d.png)

网页生成过程：

- `HTML`被 HTML 解析器解析成`DOM` 树
- `css`则被 css 解析器解析成`CSSOM `树
- 结合`DOM`树和`CSSOM`树，生成一棵渲染树(`Render Tree`)
- 生成布局（`flow`），即将所有渲染树的所有节点进行平面合成
- 将布局绘制（`paint`）在屏幕上

**重排(也称回流):** 当`DOM`的变化影响了元素的几何信息(`DOM`对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。 触发：

1. 添加或者删除可见的 DOM 元素
2. 元素尺寸改变——边距、填充、边框、宽度和高度

**重绘：** 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。 触发：

- 改变元素的`color、background、box-shadow`等属性

**重排优化建议：**

1. 分离读写操作
2. 样式集中修改
3. 缓存需要修改的`DOM`元素
4. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
5. 动画开始`GPU`加速，`translate`使用`3D`变化

`transform` 不重绘，不回流 是因为`transform`属于合成属性，对合成属性进行`transition/animate`动画时，将会创建一个合成层。这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。浏览器会通过重新复合来创建动画帧。

## 2.22 css 怎么开启硬件加速(GPU 加速)

浏览器在处理下面的 css 的时候，会使用 GPU 渲染

- transform（当 3D 变换的样式出现时会使用 GPU 加速）
- opacity
- filter
- will-change

```javascript
采用 transform: translateZ(0)
采用 transform: translate3d(0, 0, 0)
使用 CSS 的 will-change属性。 will-change 可以设置为opacity、transform、top、left、bottom、right。
```

> 注意！层爆炸，由于某些原因可能导致产生大量不在预期内的合成层，虽然有浏览器的层压缩机制，但是也有很多无法进行压缩的情况，这就可能出现层爆炸的现象（简单理解就是，很多不需要提升为合成层的元素因为某些不当操作成为了合成层）。解决层爆炸的问题，最佳方案是打破 overlap 的条件，也就是说让其他元素不要和合成层元素重叠。简单直接的方式：使用 3D 硬件加速提升动画性能时，最好给元素增加一个 z-index 属性，人为干扰合成的排序，可以有效减少创建不必要的合成层，提升渲染性能，移动端优化效果尤为明显。

# 三、Javascript 部分

## 3.1 js 数据类型有哪些

Number 、String、Boolean、Null、Undefined、Object、Symbol、BigInt

## 3.2 怎么判断对象还是数组？

**最少 3 种以上**

- **instanceof**
- **对象的 constructor 属性**
- **Object.prototype.toString.call(arr)**
- **Array.isArray()**

## 3.3 new 关键字做了什么

- 创建一个简单空对象
- 原型的执行，确定对象 o 的原型链
- 绑定 this 对象为 o，传入参数；执行 Person 构造函数，进行属性和方法的赋值操作
- 返回结果

## 3.4 Javascript 事件流

DOM 事件流是有两种的，一种是捕获型事件流，另外一种是冒泡型事件流，两者其实都很好理解，下面我们就来详细介绍一下，为了大家更好的理解，我们就先介绍下冒泡型事件流

1. 冒泡型事件流 **"冒泡"**：没错就是你心中想的，冒泡就是我们平时可以常见的，例如水中的气泡往上冒，这就是冒泡，所以冒泡型事件流，就是当你点击目标元素的时候，当前所触发的一些事件会向父元素中传递，这就是所谓的事件冒泡,如果大家还是有不理解的地方，可以直接看后面的代码
2. 捕获型事件流 捕获型事件流正好是与冒泡型事件流相反的，当你点击目标元素的时候，在该目标元素上点击触发的事件，会从父元素向下传递
3. 其实，DOM 标准规定事件流包括三个阶段：事件捕获阶段、处于目标阶段和事件冒泡阶段。 事件捕获阶段：实际目标在捕获阶段不会接收事件。也就是在捕获阶段，事件从 document 到再到就停止了。 处于目标阶段：事件在上发生并处理。但是事件处理会被看成是冒泡阶段的一部分。 冒泡阶段：事件又传播回文档。

## 3.5 怎么阻止冒泡事件

w3c: event.stopPropagation()

IE: window.event.cancelBubble = true

## 3.6 怎么阻止默认事件

event.preventDefault()

## 3.7 什么是事件委托

用事件冒泡的原理，自己所触发的事件， 让他的父元素代替执行。

## 3.8 什么是抖动 节流

参考:

https://blog.csdn.net/Welkin_qing/article/details/88126044

- 函数防抖

  **规定函数至少间隔多久执行**

- 函数节流

  **规定函数在某时间段内最多执行一次**

函数防抖和函数节流的对比
不管是函数节流还是函数防抖，减少的都是事件处理程序的调用频率，而不是时间的调用频率

何时使用函数防抖，何时使用函数节流？
当我们只需要处理最后一次触发事件时，用函数防抖。（例如：窗口大小变化，并不需要计算中间变化的过程，只需要窗口大小改变完成后的值）
当事件触发过于频繁，我们需要限制事件处理程序的调用频率时，用函数节流

## 3.9 什么是深浅拷贝怎么实现

浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用. 不拷贝地址，两者属性值指向同一内存空间。简单来讲，就是改变其中一个对象，另一个对象也会跟着改变。

拷贝对象各个层级的属性。简单的讲，就是复制出来的每个对象都有属于自己的内存空间，不会互相干扰。

实现: 最少 2 种 -- 深度拷贝

```javascript
// 深拷贝：对对象内部进行深拷贝，支持 Array、Date、RegExp、DOM
const deepCopy = (sourceObj) => {
  // 如果不是对象则退出（可停止递归）
  if (typeof sourceObj !== "object") return;

  // 深拷贝初始值：对象/数组
  let newObj = sourceObj instanceof Array ? [] : {};

  // 使用 for-in 循环对象属性（包括原型链上的属性）
  for (let key in sourceObj) {
    // 只访问对象自身属性
    if (sourceObj.hasOwnProperty(key)) {
      // 当前属性还未存在于新对象中时
      if (!(key in newObj)) {
        if (sourceObj[key] instanceof Date) {
          // 判断日期类型
          newObj[key] = new Date(sourceObj[key].getTime());
        } else if (sourceObj[key] instanceof RegExp) {
          // 判断正则类型
          newObj[key] = new RegExp(sourceObj[key]);
        } else if (
          typeof sourceObj[key] === "object" &&
          sourceObj[key].nodeType === 1
        ) {
          // 判断 DOM 元素节点
          let domEle = document.getElementsByTagName(
            sourceObj[key].nodeName
          )[0];
          newObj[key] = domEle.cloneNode(true);
        } else {
          // 当元素属于对象（排除 Date、RegExp、DOM）类型时递归拷贝
          newObj[key] =
            typeof sourceObj[key] === "object"
              ? deepCopy(sourceObj[key])
              : sourceObj[key];
        }
      }
    }
  }

  return newObj;
};

// deepCopy 函数测试效果
const objA = {
  name: "jack",
  birthday: new Date(),
  pattern: /jack/g,
  body: document.body,
  others: [123, "coding", new Date(), /abc/gim],
};

const objB = deepCopy(objA);
console.log(objA === objB); // false
console.log(objA.others === objB.others); // false
console.log(objA, objB); // 对象内容一样
```

## 3.20 call、bind 和 apply 的区别

1.  都可以更改 this 指向

2.  call，bind 后面的第一个参数是指向的对象，第二个参数是往对象传的值

3.  apply 后面的第一个参数是指向的对象，第二个参数是数组，数组里面是往对象传的值（arguments 全部参数）

4.  call 和 apply 更改 this 指向会自动调用，bind 需要手动调用

## 3.21 cookie，sessionStorage 和 localStorage 的区别是什么

1. 都可以用来存储数据

2. cookie 一条数据大小不能超过 4KB ，最多不能存储超过 20 条，如果没有设置过期时间，那么在浏览器关闭后消失

3. sessionStorage 是会话存储，一条大小不能超过 5M，数量没有限制，关掉页面数据消失

4. localStorage 本地存储，一条大小不超过 5M，数量没有限制，除非主动删除，否则数据不会消失

## 3.22 什么是原型链

当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的**proto**隐式原型上查找，即它的构造函数的 prototype，如果还没有找到就会再在构造函数的 prototype 的**proto**中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链
![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg-blog.csdnimg.cn%2F20200324172235599.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjMzODU4NA%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70&refer=http%3A%2F%2Fimg-blog.csdnimg.cn&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1634980485&t=0701089532bb49fd02da93167363a8db)

## 3.23 什么是闭包？闭包的作用场景是什么？

闭包指的是一个函数可以访问另一个函数作用域中变量

各种专业文献上的"闭包"（closure）定义非常抽象，很难看懂。我的理解是，**闭包就是能够读取其他函数内部变量的函数**。

由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把**闭包简单理解成"定义在一个函数内部的函数"**。

所以，在本质上，**闭包就是将函数内部和函数外部连接起来的一座桥梁。**

- 采用函数引用方式的 setTimeout 调用

- 小范围代替全局变量

- 访问私有变量的特权方法

- 模块化

  使用作用域链的形式说明闭包是什么？

  当外层函数执行时，内层函数进行定义，此时内层函数生成作用域链，作用域链中包含外层函数的 AO 对象，导致 AO 无法释放，这就形成了闭包。

**闭包缺点：**会导致函数的变量一直保存在内存中，过多的闭包可能会导致内存泄漏

## 3.24 同步异步的区别是什么

**\*\*同步：上一个任务没有执行完，下一个任务不能开启\*\***

**\*\*异步：即便上一个任务没有执行完，下一个任务仍然可以开启\*\***

## 3.25 Javascript 中异步操作 及其 js 中 EventLoop 事件循环

**(1)** **\*\*setTimeout 延时器\*\***

**(2)** **\*\*setInterval 计时器\*\***

**(3)** **\*\*数据请求\*\***

EventLoop ： 暂定

## 3.26 es6 有哪些新特性

​ 1.let 关键字，声明变量

​ 2.const 关键字，声明常量

​ 3.模板字符串

​ 4.箭头函数

​ 5.对象和数组解构

​ 6.Map、Set 集合

​ 7.Promise 对象

​ 8.引入 class 关键字

​ 9.ES6 模块化

## 3.27 var 和 let、Const 的区别是什么

(1) let 声明的变量只能先声明后赋值

(2) 只能使用 let 对同一个变量声明一次

(3) let 声明的变量有块级作用域

## 3.28 数组的常用方法有哪些？

pop、push、cancat、shift、unshift、join、filter、map、some、everything、reduce、find、splice

## 3.29 字符串常用的方法有哪些？

substr、slice、concat、

## 3.30 数组怎么进行去重 （3 种以上方法）

- 利用 ES6 Set 去重（ES6 中最常用）
- 利用 for 嵌套 for，然后 splice 去重（ES5 中最常用）
- 利用 indexOf 去重
- 利用 includes
- 利用 filter

## 3.31 数组扁平化

- #### ES5+递归

- #### ES6+reduce+递归

- ### ES6 Flat 函数

## 3.32 什么是纯函数

    纯函数的概念：一个函数的返回结果只依赖其参数，并且执行过程中没有副作用。

## 3.33 什么是高阶函数

一个函数作为另外一个函数的参数或者一个函数的返回值为另外一个函数这种函数就称之为高阶函数。

## 3.34 函数柯里化及其用途

柯里化，英语：Currying，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。
应用:
参考地址: https://blog.csdn.net/qq_18404993/article/details/108836643 -参数复用

- 兼容性检测：提前确认/提前返回
- 延迟执行

## 3.35 怎么解决异步回调地狱问题?

Promise、generator、async await

## 3.36 说一下 Promise 的使用？

Promise 是异步编程的一种解决方案，在 ES6 中 Promise 被列为了正式规范，统一了用法，原生提供了 Promise 对象。**Promise 承诺：默认情况下是等待状态 pending，如果有一天状态转变为成功就成功了，如果状态变成失败就失败了。状态一旦改变了就不能再改变了。**

三种状态： pending，Resolved， Rejected

- then 方法
- catch 的用法
- finally 方法
- all 的用法
- race 的用法
- Promise 的静态方法

## 3.37 怎么将伪数组转换成真正的数组？

- ```javascript
  Array.prototype.slice.call(arguments, 0); // 使用slice方法实现
  ```

- ```javascript
  Array.from(arguments); // 使用ES6中的函数
  ```

- ```javascript
  [...arguments];
  ```

## 3.38 斐波那契数列怎么实现？

- 第一种实现：普通递归

  ```javascript
  function fibonacci(n) {
    if (n == 1 || n == 2) {
      return 1;
    }
    return fibonacci(n - 2) + fibonacci(n - 1);
  }
  fibonacci(30);
  ```

- 第二种实现: 改进递归-把前两位数字做成参数避免重复计算

  ```javascript
  function fibonacci(n) {
    function fib(n, v1, v2) {
      if (n == 1) return v1;
      if (n == 2) return v2;
      else return fib(n - 1, v2, v1 + v2);
    }
    return fib(n, 1, 1);
  }
  fibonacci(30);
  ```

- 第三种实现：改进递归-利用闭包特性把运算结果存储在数组里，避免重复计算

  ```javascript
  var fibonacci = (function () {
    let memo = [0, 1];
    let fib = function (n) {
      if (memo[n] == undefined) {
        memo[n] = fib(n - 2) + fib(n - 1);
      }
      return memo[n];
    };
    return fib;
  })();
  fibonacci(30);
  ```

- 第四种实现: 改进递归-摘出存储计算结果的功能函数

  ```javascript
  var memoizer = function (func) {
    let memo = [];
    return function (n) {
      if (memo[n] == undefined) {
        memo[n] = func(n);
      }
      return memo[n];
    };
  };
  var fibonacci = memoizer(function (n) {
    if (n == 1 || n == 2) {
      return 1;
    }
    return fibonacci(n - 2) + fibonacci(n - 1);
  });
  fibonacci(30);
  ```

- 第五种: 普通 for 循环

  ```javascript
  function fibonacci(n) {
    var n1 = 1,
      n2 = 1,
      sum;
    for (let i = 2; i < n; i++) {
      sum = n1 + n2;
      n1 = n2;
      n2 = sum;
    }
    return sum;
  }
  fibonacci(30);
  ```

- 第六种：for 循环+解构赋值

  ```javascript
  var fibonacci = function (n) {
    let n1 = 1;
    n2 = 1;
    for (let i = 2; i < n; i++) {
      [n1, n2] = [n2, n1 + n2];
    }
    return n2;
  };
  fibonacci(30);
  ```

  这六种方法需要会 第六种 和 第三种。其他需要了解

## 3.39 冒泡算法

```javascript
//从小到大
function BubbleSort(arr){
    var i,j,temp;
    for(i=0;i<arr.length-1;i++){
        for(j=i+1;j<arr.length;j++){
            if(arr[i]>arr[j]){
                temp=arr[j];
                arr[j]=arr[i];
                arr[i]=temp;
            }
        }
    }
    return arr;
}
var arr=[10,7,9,11,22,33,4,2,0,1000];
BubbleSort(arr);  17 console.log(arr); //[0, 2, 4, 7, 9, 10, 11, 22, 33, 1000]
```

## 3.40 快排算法

参考地址： https://www.cnblogs.com/hjx-blog/articles/9183453.html

```javascript
var quickSort_New = function (ary, left, right) {
  if (left >= right) {
    return ary;
  }

  var i = left,
    j = right;
  base = ary[left];

  while (i < j) {
    // 从右边起，寻找比基数小的数
    while (i < j && ary[j] >= base) {
      j--;
    }

    // 从左边起，寻找比基数大的数
    while (i < j && ary[i] <= base) {
      i++;
    }

    if (i < j) {
      var temp = ary[i];
      ary[i] = ary[j];
      ary[j] = temp;
    }
  }

  ary[left] = ary[i];
  ary[i] = base;

  quickSort_New(ary, left, i - 1);
  quickSort_New(ary, i + 1, right);

  return ary;
};
```

## 3.41 面向对象继承方式（ES5）

- 原型链的方式来实现继承

- 借用构造函数

- 组合继承

- 寄生式继承

- 寄生式组合继承

## 3.42 EventLoop 事件循环

```
JS`是单线程的，为了防止一个函数执行时间过长阻塞后面的代码，所以会先将同步代码压入执行栈中，依次执行，将异步代码推入异步队列，异步队列又分为宏任务队列和微任务队列，因为宏任务队列的执行时间较长，所以微任务队列要优先于宏任务队列。微任务队列的代表就是，`Promise.then`，`MutationObserver`，宏任务的话就是`setImmediate setTimeout setInterval
```

## 3.43 介绍一下垃圾回收机制

垃圾回收机制大体上分为两种检测手段，引用计数与标记清除。

从 2012 年起，所有现代浏览器都使用了标记清除垃圾回收算法，但老版本的 IE6 除外。

如何避免内存泄漏：

**1.尽量减少全局变量**

**2.移除被遗忘的定时器或回调函数**

**3.及时释放闭包中的变量**

**4.DOM 的引用时 不再使用 DOM 及时清除**

## 3.43 Proxy 的作用?有哪些方法？

Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

方法只需记住关键的几个即可：

- **get(target, propKey, receiver)**：拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。 // 记住
- **set(target, propKey, value, receiver)**：拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。// 记住
- **has(target, propKey)**：拦截`propKey in proxy`的操作，返回一个布尔值。
- **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。 // 记住
- **ownKeys(target)**：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。
- **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。 // 记住
- **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。 // 记住
- **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。
- **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。
- **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。
- **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。
- **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。 // 记住
- **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

## 3.44 前端优化之渲染百万条数据不卡顿

参考网址: https://juejin.cn/post/7011040313418448926#heading-7

Document.createDocumentFragment()： 用来创建虚拟 DOM

window.requestAnimationFrame：告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。

`requestAnimationFrame` 会把每一帧中的所有`DOM`操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒 60 帧。

在隐藏或不可见的元素中，`requestAnimationFrame`将不会进行重绘或回流，这当然就意味着更少的的`cpu`，`gpu`和内存使用量。

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <ul></ul>

    <script>
      // createDocumentFragment
      // requestAnimationFrame

      // 百万条数据
      let total = 1000000;
      // 单次插入 可自定义
      let once = 20;
      // 需要插入的次数 向上取整
      let loopCount = Math.ceil(total / once);
      // 当前渲染次数
      let countRender = 0;

      function render() {
        // 需要插入的目标对象
        const targetElement = document.querySelector("ul");
        // 文档因为存在片段于内存中，并不在DOM树中，将所以子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。
        // 创建一个虚拟Dom节点 插入真实文档之前不会触发dom渲染、回流等操作
        // 因此能够很大程度减少dom操作所带来的的性能损耗
        const fragment = document.createDocumentFragment();

        // 对虚拟节点插入dom节点，也不会触发真是dom操作，同上
        for (let i = 0; i < 20; i++) {
          // 搞个节点
          const li = document.createElement("li");
          // 给li搞点内容
          li.innerHTML = Math.random();
          // 插入到虚拟节点
          fragment.appendChild(li);
        }
        // 插入到真实节点的时候，只会把虚拟fragment下的子孙节点插入
        targetElement.appendChild(fragment);
        // 渲染次数加1，控制递归的次数
        countRender++;
        // // 递归调用
        if (countRender < loopCount) {
          // window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。
          // 回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。
          // 能够把每次dom的操作汇总在下一次重绘之前更新动画帧
          // 因此在浏览器单线程的机制下，能够无卡顿的加载，百万级列表
          window.requestAnimationFrame(render);
        }
      }

      // 执行渲染
      render();
    </script>
  </body>
</html>
```

还有一种方案可以提高性能：

如果对于大量的数据，只应用于展示的话，可以使用**`Object.freeze()`** 方法可以**冻结**一个对象。一个被冻结的对象再也不能被修改；（这样可以让 Vue 不对对象增加 getter 和 setter 操作，从而提高性能）

## 3.45 手写实现 Promise

```javascript
const PENDING = 'PENDING';
const FULFILLED = 'FULFILLED';
const REJECTED = 'REJECTED';

const resolvePromise = (promise2, x, resolve, reject) => {
  // 自己等待自己完成是错误的实现，用一个类型错误，结束掉 promise  Promise/A+ 2.3.1
  if (promise2 === x) {
    return reject(new TypeError('Chaining cycle detected for promise #<Promise>'))
  }
  // Promise/A+ 2.3.3.3.3 只能调用一次
  let called;
  // 后续的条件要严格判断 保证代码能和别的库一起使用
  if ((typeof x === 'object' && x != null) || typeof x === 'function') {
    try {
      // 为了判断 resolve 过的就不用再 reject 了（比如 reject 和 resolve 同时调用的时候）  Promise/A+ 2.3.3.1
      let then = x.then;
      if (typeof then === 'function') {
        // 不要写成 x.then，直接 then.call 就可以了 因为 x.then 会再次取值，Object.defineProperty  Promise/A+ 2.3.3.3
        then.call(x, y => { // 根据 promise 的状态决定是成功还是失败
          if (called) return;
          called = true;
          // 递归解析的过程（因为可能 promise 中还有 promise） Promise/A+ 2.3.3.3.1
          resolvePromise(promise2, y, resolve, reject);
        }, r => {
          // 只要失败就失败 Promise/A+ 2.3.3.3.2
          if (called) return;
          called = true;
          reject(r);
        });
      } else {
        // 如果 x.then 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.3.4
        resolve(x);
      }
    } catch (e) {
      // Promise/A+ 2.3.3.2
      if (called) return;
      called = true;
      reject(e)
    }
  } else {
    // 如果 x 是个普通值就直接返回 resolve 作为结果  Promise/A+ 2.3.4
    resolve(x)
  }
}

class Promise {
  constructor(executor) {
    this.status = PENDING;
    this.value = undefined;
    this.reason = undefined;
    this.onResolvedCallbacks = [];
    this.onRejectedCallbacks= [];

    let resolve = (value) => {
      if(this.status ===  PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onResolvedCallbacks.forEach(fn=>fn());
      }
    }

    let reject = (reason) => {
      if(this.status ===  PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn=>fn());
      }
    }

    try {
      executor(resolve,reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onFulfilled, onRejected) {
    //解决 onFufilled，onRejected 没有传值的问题
    //Promise/A+ 2.2.1 / Promise/A+ 2.2.5 / Promise/A+ 2.2.7.3 / Promise/A+ 2.2.7.4
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
    //因为错误的值要让后面访问到，所以这里也要跑出个错误，不然会在之后 then 的 resolve 中捕获
    onRejected = typeof onRejected === 'function' ? onRejected : err => { throw err };
    // 每次调用 then 都返回一个新的 promise  Promise/A+ 2.2.7
    let promise2 = new Promise((resolve, reject) => {
      if (this.status === FULFILLED) {
        //Promise/A+ 2.2.2
        //Promise/A+ 2.2.4 --- setTimeout
        setTimeout(() => {
          try {
            //Promise/A+ 2.2.7.1
            let x = onFulfilled(this.value);
            // x可能是一个proimise
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            //Promise/A+ 2.2.7.2
            reject(e)
          }
        }, 0);
      }

      if (this.status === REJECTED) {
        //Promise/A+ 2.2.3
        setTimeout(() => {
          try {
            let x = onRejected(this.reason);
            resolvePromise(promise2, x, resolve, reject);
          } catch (e) {
            reject(e)
          }
        }, 0);
      }

      if (this.status === PENDING) {
        this.onResolvedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onFulfilled(this.value);
              resolvePromise(promise2, x, resolve, reject);
            } catch (e) {
              reject(e)
            }
          }, 0);
        });

        this.onRejectedCallbacks.push(()=> {
          setTimeout(() => {
            try {
              let x = onRejected(this.reason);
              resolvePromise(promise2, x, resolve, reject)
            } catch (e) {
              reject(e)
            }
          }, 0);
        });
      }
    });

    return promise2;
  }
}

作者：齐小神
链接：https://juejin.cn/post/6850037281206566919
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 3.46 手写 bind 函数

```javascript
//bind实现要复杂一点  因为他考虑的情况比较多 还要涉及到参数合并(类似函数柯里化)
Function.prototype.myBind = function (context, ...args) {
  if (!context || context === null) {
    context = window;
  }
  // 创造唯一的key值  作为我们构造的context内部方法名
  let fn = Symbol();
  context[fn] = this;
  let _this = this;
  //  bind情况要复杂一点
  const result = function (...innerArgs) {
    // 第一种情况 :若是将 bind 绑定之后的函数当作构造函数，通过 new 操作符使用，则不绑定传入的 this，而是将 this 指向实例化出来的对象
    // 此时由于new操作符作用  this指向result实例对象  而result又继承自传入的_this 根据原型链知识可得出以下结论
    // this.__proto__ === result.prototype   //this instanceof result =>true
    // this.__proto__.__proto__ === result.prototype.__proto__ === _this.prototype; //this instanceof _this =>true
    if (this instanceof _this === true) {
      // 此时this指向指向result的实例  这时候不需要改变this指向
      this[fn] = _this;
      this[fn](...[...args, ...innerArgs]); //这里使用es6的方法让bind支持参数合并
      delete this[fn];
    } else {
      // 如果只是作为普通函数调用  那就很简单了 直接改变this指向为传入的context
      context[fn](...[...args, ...innerArgs]);
      delete context[fn];
    }
  };
  // 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法
  // 实现继承的方式: 使用Object.create
  result.prototype = Object.create(this.prototype);
  return result;
};

//用法如下

// function Person(name, age) {
//   console.log(name); //'我是参数传进来的name'
//   console.log(age); //'我是参数传进来的age'
//   console.log(this); //构造函数this指向实例对象
// }
// // 构造函数原型的方法
// Person.prototype.say = function() {
//   console.log(123);
// }
// let obj = {
//   objName: '我是obj传进来的name',
//   objAge: '我是obj传进来的age'
// }
// // 普通函数
// function normalFun(name, age) {
//   console.log(name);   //'我是参数传进来的name'
//   console.log(age);   //'我是参数传进来的age'
//   console.log(this); //普通函数this指向绑定bind的第一个参数 也就是例子中的obj
//   console.log(this.objName); //'我是obj传进来的name'
//   console.log(this.objAge); //'我是obj传进来的age'
// }

// 先测试作为构造函数调用
// let bindFun = Person.myBind(obj, '我是参数传进来的name')
// let a = new bindFun('我是参数传进来的age')
// a.say() //123

// 再测试作为普通函数调用
// let bindFun = normalFun.myBind(obj, '我是参数传进来的name')
//  bindFun('我是参数传进来的age')
```

## 3.47 RAF 和 RIC 是什么

**requestAnimationFrame：** 告诉浏览器在下次重绘之前执行传入的回调函数(通常是操纵 dom，更新动画的函数)；由于是每帧执行一次，那结果就是每秒的执行次数与浏览器屏幕刷新次数一样，通常是每秒 60 次。

**requestIdleCallback：**: 会在浏览器空闲时间执行回调，也就是允许开发人员在主事件循环中执行低优先级任务，而不影响一些延迟关键事件。如果有多个回调，会按照先进先出原则执行，但是当传入了 timeout，为了避免超时，有可能会打乱这个顺序。

> 这个题目可以深入去问浏览器每一帧的渲染流程 具体可以看看这篇 [requestIdleCallback 和 requestAnimationFrame 详解](https://juejin.cn/post/6844903848981577735)

# 四、网络请求

## 4.1 http 中 post 请求和 get 请求有什么区别

（1）post 更安全（不会作为 url 的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）

（2）post 发送的数据更大（get 有 url 长度限制）

（3）post 能发送更多的数据类型（get 只能发送 ASCII 字符）

（4）post 比 get 慢

（5）post 用于修改和写入数据，get 一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是 get 提交），目的是资源的获取，读取数据

## 4.2 从输入一个 URL 地址到浏览器完成渲染的整个过程？

浏览器地址栏输入 URL 并回车

浏览器查找当前 URL 是否存在缓存，并比较缓存是否过期

DNS 解析 URL 对应的 IP

根据 IP 建立 TCP 连接（三次握手）

发送 http 请求

服务器处理请求，浏览器接受 HTTP 响应

浏览器解析并渲染页面

关闭 TCP 连接（四次握手）

## 4.3 使用什么工具进行 post 请求的测试

postman

## 4.4 http 状态码有哪些

1 开头 表示临时响应并需要请求者继续执行操作的状态码。

2 开头 （请求成功）表示成功处理了请求的状态代码。

3 开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

4 开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。

5 开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

- 常见状态码

http 状态码 200 （有内容） 服务器成功处理了请求

http 状态码 204 （无内容） 服务器成功处理了请求，但没有返回任何内容

http 状态码 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。

http 状态码 302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

http 状态码 304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。

http 状态码 400 （错误请求） 服务器不理解请求的语法（一般为参数错误）。

http 状态码 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。

http 状态码 403 （禁止） 服务器拒绝请求。（一般为客户端的用户权限不够）

http 状态码 404 （未找到） 服务器找不到请求的网页。

http 状态码 500（服务器内部错误） 服务器遇到错误，无法完成请求。

## 4.5 怎么解决跨域问题

- 后台 cors
- 前端使用 jsonp 请求（后台接口必须支持 jsonp）
- 使用反向代理方式

## 4.6 http 和 TCP 协议都什么区别

HTTP 是基于 TCP 的，客户端往服务端发送一个 HTTP 请求时第一步就是要建立与服务端的 TCP 连接，也就是先三次握手，“你好，你好，你好”。从 HTTP 1.1 开始支持持久连接，也就是一次 TCP 连接可以发送多次的 HTTP 请求。

小总结：HTTP 基于 TCP

需要说出 TCP 三次握手四次挥手。

## 4.7 http 和 https 有什么区别

- HTTP 是`明文传输`，不安全的，HTTPS 是`加密传输`，安全的多

- HTTP 标准端口是`80`，HTTPS 标准端口是`443`

- HTTP 不用认证证书`免费`，HTTPS 需要认证证书`要钱`

- 连接方式不同，HTTP 三次握手，HTTPS 中 TLS1.2 版本 7 次，TLS1.3 版本 6 次

- HTTP 在 OSI 网络模型中是在`应用层`，而 HTTPS 的 TLS 是在`传输层`

- HTTP 是`无状态`的，HTTPS 是`有状态`的

## 4.8 http 和 websocket 协议有什么区别

区分这两个概念是比较有意义的，毕竟 TCP 看不见摸不着，HTTP 与 Socket 是实实在在能用到的。

- HTTP 是短连接，Socket(基于 TCP 协议的)是长连接。尽管 HTTP1.1 开始支持持久连接，但仍无法保证始终连接。而 Socket 连接一旦建立 TCP 三次握手，除非一方主动断开，否则连接状态一直保持。
- HTTP 连接服务端无法主动发消息，Socket 连接没有双方请求的发送先后限制。这点就比较重要了，因为它将决定二者分别适合应用在什么场景下。HTTP 采用“请求-响应”机制，在客户端还没发送消息给服务端前，服务端无法推送消息给客户端。必须满足客户端发送消息在前，服务端回复在后。Socket 连接双方类似 peer2peer 的关系，一方随时可以向另一方喊话。
  - 用 HTTP 的情况：双方不需要时刻保持连接在线，比如客户端资源的获取、文件上传等。
  - 用 Socket 的情况：大部分即时通讯应用(QQ、微信)、聊天室等等。

## 4.9 Ajax 请求的步骤是什么？

```
  Ajax :
      1. Asynchronous Javascript And XML（异步JavaScript和XML）, 。
      2. what : 一种创建交互式网页的开发技术。
      3. how : 刷新局部网页，而不是整个网页刷新的技术。
      4. 核心 : 使用 JavaScript 向服务器提出请求并处理响应而不阻塞用户核心对象XMLHttpRequest。
      5. 好处 : 快速响应客户端。

  核心原理：
      传统的 web 开发，js 向服务器发起请求，等待服务器处理后，响应给浏览器。浏览器接收数据并渲染。
          此时，浏览器要等待服务器的响应后，才能发起新的请求。容易阻塞，用户体验不好。
      ajax 开发，浏览器内部有一个 ajax  引擎(XMLHTTPRequest)。
          js 向 ajax 引擎发送数据。
          ajax 引擎向服务器发送请求。服务器处理完请求向 ajax 引擎响应数据。
          引擎通过事件监听函数，接收到响应的数据，并渲染。
          js 可以不必等待 ajax 引擎的响应，多次向 ajax 引擎发起请求。
```

1.首先,创建一个 XMLHttpRequest 异步对象

2.然后,设置请求方式和请求地址

3.接着,用 send 发送请求

4.然后,监听状态变化

###### 原生 ajax:

```
  <script type="text/javascript">
    // 原生ajax请求：XMLHttpRequest 这个内置的对象实现请求。

    // 1. 实例化请求对象，考虑兼容问题
    var httpAjax = null;
    if (window.XMLHttpRequest) httpAjax = new XMLHttpRequest(); // 主流浏览器
    else if (window.ActiveXObject) httpAjax = new ActiveXObject(); // IE5 IE6 浏览器

    if (httpAjax) {
      // 2. 绑定监听函数，监听请求状态的变化
      httpAjax.onreadystatechange = () => {
        // 根据请求状态，进行数据的处理
        if (httpAjax.status == 200 && httpAjax.readyState == 4) {
          console.log(httpAjax.responseText);
        }
      }
      // 3. 进行请求配置
      // open(method, url, async, username, password)
      httpAjax.open("GET", "http://localhost:8080/user", true)

      // 4. 发送请求
      httpAjax.send();
    }

  </script>


  <script>
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = () => {
      if (xhr.status == 200 && xhr.readyState == 4) {
        console.log("请求成功", xhr.responseText);
      }
    };
    xhr.open("POST", "http://localhost:8080/login", true);
    // post 请求时，设置请求头Content-Type，它是用于指定请求参数，以什么样的格式发送给后端。告诉服务器，我前端发送的请求参数是什么类型的。

    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
    xhr.send("a=100&b=200");
  </script>
```

###### node 配置 api

```
const express = require("express");
const app = express();

// 配置全局跨域中间件
const cors = require("cors");
app.use(cors());

// express.urlencoded() 这个中间件，只能解析前端发送的 application/x-www-form-urlencoded 这种类型的数据到req.body中。
app.use(express.urlencoded({ extends: false }));

// express.json() 这个中间件，只能解析前端发送的 application/json 这种类型的数据到req.body中。
app.use(express.json());

app.get("/user", (req, res) => {
  // res.send("恭喜你，获取信息成功");
  console.log("++++", req.query);
  // res.json(): 给前端返回json数据
  res.json({
    name: "admin",
    info: "是一名海外华人",
    hobby: "荒野求生",
  });
});

app.post("/login", (req, res) => {
  console.log("----", req.body);
  res.send(JSON.stringify({ msg: "登录成功", status: 1 }));
});

app.listen(8080, () => {
  console.log("服务已启动");
});
```

## 4.10 http 的强制缓存和协商缓存是什么？

参考地址： https://juejin.cn/post/6974529351270268958#heading-20

- 强制缓存就是文件直接从本地缓存中获取，不需要发送请求。

![强制缓存 图1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5f04f37b588462ab7abf025cfa7c5a8~tplv-k3u1fbpfcp-watermark.awebp)

![强制缓存 图2](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a925e79ee724f1099df19d9e61fff32~tplv-k3u1fbpfcp-watermark.awebp)

从上图中可以看到，此时浏览器已经接收到 `cache-control` 的值，那么这个时候浏览器再次发送请求时，它会先检查它的 `cache-control` 是否过期，如果没有过期则直接从本地缓存中拉取资源，返回到客户端，而无需再经过服务器。

- 协商缓存，也叫对比缓存。

  它是一种**服务端的缓存策略**，即通过服务端来判断某件事情是不是可以被缓存。

  服务端判断客户端的资源，是否和服务端资源一样，如果一致则返回 `304` ，反之返回 `200` 和最新的资源。

![协商缓存 图1](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5684907367bc4101b4e3f4bc23cdb760~tplv-k3u1fbpfcp-watermark.awebp)

## 4.11 什么是 XSS、CSRF 攻击

CSRF 即 Cross-site request forgery(跨站请求伪造)，是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。

XSS 即 Cross Site Scripting（跨站脚本），指的是通过利用网页开发时留下的漏洞，注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。常见的例如在评论区植入 JS 代码，用户进入评论页时代码被执行，造成页面被植入广告、账号信息被窃取

**如何防御 CSRF 攻击**

- 验证`Token`：浏览器请求服务器时，服务器返回一个 token，每个请求都需要同时带上 token 和 cookie 才会被认为是合法请求

- 验证`Referer`：通过验证请求头的 Referer 来验证来源站点，但请求头很容易伪造

- 设置`SameSite`：设置 cookie 的 SameSite，可以让 cookie 不随跨域请求发出，但浏览器兼容不一

**如何防御 XSS 攻击**

- **输入检查**：对输入内容中的`<script><iframe>`等标签进行转义或者过滤
- **设置 httpOnly**：很多 XSS 攻击目标都是窃取用户 cookie 伪造身份认证，设置此属性可防止 JS 获取 cookie
- **开启 CSP**，即开启白名单，可阻止白名单以外的资源加载和运行

## 4.1 如果使用 axios 取消请求？

```javascript
参考Vue项目;
```

## 4.2 https 加密过程是怎样的

参考: https://juejin.cn/post/6844904150115827725

##

# 五、Vue 面试题

## 5.1 Vue 常见的指令

v-text、v-cloak、v-once、v-html、v-on、v-bind

v-text:绑定文本，不能加载标签

v-html:绑定文本，可以加载标签

v-bind: **\*\*用于绑定数据和元素属性\*\***

v-if:条件判断，为真添加元素，为假删除元素

v-for:循环

v-model:双向数据绑定

v-show:条件判断，为真显示，为假不显示

## 5.2 MVC 和 MVVM

MVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范

- Model（模型）：是应用程序中用于处理应用程序数据逻辑的部分。通常模型对象负责在数据库中存取数据
- View（视图）：是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的
- Controller（控制器）：是应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据

MVC 的思想：一句话描述就是 Controller 负责将 Model 的数据用 View 显示出来，换句话说就是在 Controller 里面把 Model 的数据赋值给 View。

##### MVVM

MVVM 新增了 VM 类

- ViewModel 层：做了两件事达到了数据的双向绑定 一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。实现的方式是：数据绑定。二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。实现的方式是：DOM 事件监听。

MVVM 与 MVC 最大的区别就是：它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，我们不用再自己手动操作 Dom 元素，来改变 View 的显示，而是改变属性后该属性对应 View 层显示会自动改变（对应 Vue 数据驱动的思想）

整体看来，MVVM 比 MVC 精简很多，不仅简化了业务与界面的依赖，还解决了数据频繁更新的问题，不用再用选择器操作 DOM 元素。因为在 MVVM 中，View 不知道 Model 的存在，Model 和 ViewModel 也观察不到 View，这种低耦合模式提高代码的可重用性

## 5.3 **1.** v-if 与 v-for 为什么不建议一起使用

v-for 和 v-if 不要在同一个标签中使用,因为解析时先解析 v-for (**优先级高**)再解析 v-if (**优先级低**)。如果遇到需要同时使用时可以考虑写成计算属性的方式。

## 5.4 data 为什么必须为函数

组件中的 data 写成一个函数，数据以函数返回值形式定义，这样每复用一次组件，就会返回一份新的 data，类似于给每个组件实例创建一个私有的数据空间，让各个组件实例维护各自的数据。而单纯的写成对象形式，就使得所有组件实例共用了一份 data，就会造成一个变了全都会变的结果

## 5.5 插槽有哪些？

设置在自组件内部的`插槽`像一个盒子，位置由子组件决定，放什么内容由父组件决定。

实现了内容分发，提高了组件自定义的程度，让组件变的更加灵活

1. **默认插槽：**

无需`name`属性，取子组件肚子里第一个元素节点作为默认插槽。

​ 2.**具名插槽：**

在多个插槽的情况下使用，利用`name`标识插槽。

​ 3. **作用域插槽：**

子组件给父组件传递数据。

## 5.6 **1.** Vue 循环的 key 作用

如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法。key 是为 Vue 中 vnode 的唯一标记，通过这个 key，我们的 diff 操作可以更准确、更快速

**更准确**：因为带 key 就不是就地复用了，在 sameNode 函数 a.key === b.key 对比中可以避免就地复用的情况。所以会更加准确。

**更快速**：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快

## 5.7 Vue 双向数据绑定原理（响应式原理）

**一：**整体思路是数据劫持+观察者模式

对象内部通过 defineReactive 方法，使用 Object.defineProperty 将属性进行劫持（只会劫持已经存在的属性），数组则是通过重写数组方法来实现。当页面使用对应属性时，每个属性都拥有自己的 dep 属性，存放他所依赖的 watcher（依赖收集），当属性变化后会通知自己对应的 watcher 去更新(派发更新)。

**二：**原理:采用数据劫持，结合发布者-订阅者模式的方式，通过 Object.defineProperty（）来劫持各个属性的 setter/getter，在数据变动时发布消息给订阅者，触发相应监听回调。

当把一个普通 js 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty（） 将它们转为 setter/getter。

用户看不到 setter/getter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。

## 5.8 Vue 生命周期钩子函数

**beforeCreate** 在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问

**created** 实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。这里没有$el,如果非要想与 Dom 进行交互，可以通过 vm.$nextTick 来访问 Dom

**beforeMount** 在挂载开始之前被调用：相关的 render 函数首次被调用。

**mounted** 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点

**beforeUpdate** 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁（patch）之前。可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程

**updated** 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新，该钩子在服务器端渲染期间不被调用。

**beforeDestroy** 实例销毁之前调用。在这一步，实例仍然完全可用。我们可以在这时进行善后收尾工作，比如清除计时器。

**destroyed** Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。

**activated** keep-alive 专属，组件被激活时调用

**deactivated** keep-alive 专属，组件被销毁时调用

## 5.9 Vue 组件之间数据传递的方式有几种？

props 和$emit 父组件向子组件传递数据是通过 prop 传递的，子组件传递数据给父组件是通过$emit 触发事件来做到的

$parent,$children 获取当前组件的父组件和当前组件的子组件

$attrs 和$listeners A->B->C。Vue 2.4 开始提供了$attrs 和$listeners 来解决这个问题

父组件中通过 provide 来提供变量，然后在子组件中通过 inject 来注入变量。(官方不推荐在实际业务中使用，但是写组件库时很常用)

$refs 获取组件实例

eventBus 兄弟组件数据传递 这种情况下可以使用事件总线的方式

vuex 状态管理

## 5.10 VueRouter 路由守卫有哪些？执行顺序是什么？

1、全局守卫

​ beforeEach 全局前置守卫

​ beforeResolve 全局解析守卫

​ afterEach 全局后置守卫

2、独享守卫

​ beforeEnter

3、 组件内守卫

​ beforeRouteEnter 组件前置守卫 (该守卫没有 this)

​ beforeRouteUpdate 路由改变但是组件被复用时

​ beforeRouteLeave 组件后置守卫

**完整的导航解析流程:**

1. 导航被触发。
2. 在失活的组件里调用 beforeRouteLeave 守卫。
3. 调用全局的 beforeEach 守卫。
4. 在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。
5. 在路由配置里调用 beforeEnter。
6. 解析异步路由组件。
7. 在被激活的组件里调用 beforeRouteEnter。
8. 调用全局的 beforeResolve 守卫 (2.5+)。
9. 导航被确认。
10. 调用全局的 afterEach 钩子。
11. 触发 DOM 更新。
12. 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。

## 5.11 Vue 当中的状态管理的作用，以及属性的作用是什么？

vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）

主要包括以下几个模块：

- State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
- Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
- Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
- Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。
- Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。

## 5.12 Vue 项目当中怎么解决跨域问题？

在前后端分离的网站架构中，服务器经常要配置反向代理，使前端通过固定地址访问后端接口，这样后端服务可以采取负载均衡等性能优化措施，对前端应用透明。

假设前端服务器地址为：`http://127.0.0.1:8080`，后端实际服务地址为：`http://server/web-service/userList` ，由于涉及到跨域的问题，前端无法直接发 http 请求给此地址，只能发送同域下的 api 请求例如：`http://127.0.0.1:8080/api/userList`， 通过上文介绍，我们了解到需要在前端服务器上配置反向代理，实现将 api 请求转发至后台服务器的目的。

在 vue.config.js 中配置:

```javascript
module.exports = {
  devServer: {
    // 配置反向代理
    proxy: {
      "/ajax": {
        // 以/ajax开头的请求
        target: "https://m.maoyan.com", // 以/ajax开头的请求，全部代理到https://m.maoyan.com上
        // ws: true,
        changeOrigin: true,
      },
      "/foo": {
        target: "<other_url>",
      },
    },
  },
};
```

## 5.13 Vue 项目怎么打包 app？

- 修改打包后资源引用为相对路径

  Vue.config.js 将`baseUrl`改为`'./'`

- 用 webpack 将项目打包为 dist 文件

  npm run build

- 打开 Huilder 点击打开目录 找到刚刚的 dist 文件夹，取好项目名称。

- 右点击项目，将项目转换为 App

- 然后进行 mainfest 文件配置，制作 app 图标和启动页 点击进行云打包进行打包

- 然后下载打包好之后的.apk 文件即可。

## 5.14 怎么解决打包空白问题？

- vue cli4 版本的 配置文件是 vue.config.js , 添加下面红框的内容即可, 将路径设置为相对路径:

![在这里插入图片描述](D:\ftp\210\资料\面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDA0MDEwNw==,size_16,color_FFFFFF,t_70)

- 然后 找到 路由配置 index.js 文件 , 如果 mode 设置的是 history 就注释掉

  ![在这里插入图片描述](D:\ftp\210\资料\面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDA0MDEwNw==,size_16,color_FFFFFF,t_70)

- 重新打包

## 5.15 Vue 的 diff 算法是什么?

![diff算法.png](D:\ftp\210\资料\面试题\1)

## 5.16 v-if 和 v-show 的区别

v-if 在编译过程中会被转化成三元表达式,条件不满足时不渲染此节点。

v-show 会被编译成指令，条件不满足时控制样式将对应节点隐藏 （display:none）

**使用场景**

v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景

v-show 适用于需要非常频繁切换条件的场景

## 5.17 computed 和 watch 的区别和运用的场景

computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容，它可以设置 getter 和 setter。

watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。

计算属性一般用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑

## 5.18 Vue 如何检测数组变化

数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写(AOP 切片思想)

所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新

## 5.19 vue3.0 用过吗 了解多少

- 响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty

- 组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。

- 模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级

- 其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。

  Vue3.0 新特性以及使用经验总结 [传送门](https://juejin.cn/post/6940454764421316644)

## 5.23 Vue3.0 和 2.0 的响应式原理区别

Vue3.x 改用 Proxy 替代 Object.defineProperty。因为 Proxy 可以直接监听对象和数组的变化，并且有多达 13 种拦截方法。

**Proxy 的优势**如下:

- Proxy 可以直接监听对象而非属性
- Proxy 可以直接监听数组的变化
- Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是 Object.defineProperty 不具备的
- Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而 Object.defineProperty 只能遍历对象属性直接修改
- Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利

**Object.defineProperty 的优势**如下:

- 兼容性好,支持 IE9

## 5.24 虚拟 DOM 是什么 有什么优缺点

由于在浏览器中操作 DOM 是很昂贵的。频繁的操作 DOM，会产生一定的性能问题。这就是虚拟 Dom 的产生原因。Vue2 的 Virtual DOM 借鉴了开源库 snabbdom 的实现。Virtual DOM 本质就是用一个原生的 JS 对象去描述一个 DOM 节点，是对真实 DOM 的一层抽象。

**优点：**

1. 保证性能下限： 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
2. 无需手动操作 DOM： 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
3. 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

**缺点:**

1. 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。
2. 首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算，会比 innerHTML 插入慢。

## 5.25 Vuex 页面刷新数据丢失怎么解决

需要做 vuex 数据持久化 一般使用本地存储的方案来保存数据 可以自己设计存储方案 也可以使用第三方插件

推荐使用 vuex-persist 插件，它就是为 Vuex 持久化存储而生的一个插件。不需要你手动存取 storage ，而是直接将状态保存至 cookie 或者 localStorage 中

## 5.26 Vuex 为什么要分模块并且加命名空间

**模块**:由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块。

**命名空间**：默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。

## 5.27 使用过 Vue SSR 吗？说说 SSR

SSR 也就是服务端渲染，也就是将 Vue 在客户端把标签渲染成 HTML 的工作放在服务端完成，然后再把 html 直接返回给客户端。

**优点：**

SSR 有着更好的 SEO、并且首屏加载速度更快

**缺点：** 开发条件会受到限制，服务器端渲染只支持 beforeCreate 和 created 两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于 Node.js 的运行环境。

服务器会有更大的负载需求

## 5.28 vue 中使用了哪些设计模式

1.工厂模式 - 传入参数即可创建实例

虚拟 DOM 根据参数的不同返回基础标签的 Vnode 和组件 Vnode

2.单例模式 - 整个程序有且仅有一个实例

vuex 和 vue-router 的插件注册方法 install 判断如果系统存在实例就直接返回掉

3.发布-订阅模式 (vue 事件机制)

4.观察者模式 (响应式数据原理)

5.装饰模式: (@装饰器的用法)

6.策略模式 策略模式指对象有某个行为,但是在不同的场景中,该行为有不同的实现方案-比如选项的合并策略

...其他模式欢迎补充

## 5.29 你都做过哪些 Vue 的性能优化

**一：**

对象层级不要过深，否则性能就会差

不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）

v-if 和 v-show 区分使用场景

computed 和 watch 区分使用场景

v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if

大数据列表和表格性能优化-虚拟列表/虚拟表格

防止内部泄漏，组件销毁后把全局变量和事件销毁

图片懒加载

路由懒加载

第三方插件的按需引入

适当采用 keep-alive 缓存组件

防抖、节流运用

服务端渲染 SSR or 预渲染

**二：**

**编码阶段**

- 不要在模板里面写过多表达式
- 尽量减少`data`中的数据，`data`中的数据都会增加`getter`和`setter`，会收集对应的`watcher`
- `v-if`和`v-for`不能连用
- 如果需要使用`v-for`给每项元素绑定事件时使用事件代理
- `SPA` 页面采用`keep-alive`缓存组件
- 频繁切换的使用 v-show，不频繁切换的使用 v-if
- 循环调用子组件时添加 key，`key`保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

**SEO 优化**

- 预渲染
- 服务端渲染`SSR`，`nuxt.js`

**打包优化**

- 压缩代码
- `Tree Shaking/Scope Hoisting`
- 使用`cdn`加载第三方模块
- 多线程打包`happypack`
- `splitChunks`抽离公共文件
- `sourceMap`优化

**用户体验**

- 骨架屏
- `PWA`渐进式 Web 应用，使用多种技术来增强 web app 的功能，让网页应用呈现和原生应用相似的体验。

> 还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启`gzip`压缩等。

## 5.30 Vue.mixin 的使用场景和原理

在日常的开发中，我们经常会遇到在不同的组件中经常会需要用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 Vue 的 mixin 功能抽离公共的业务逻辑，原理类似“对象的继承”，当组件初始化时会调用 mergeOptions 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。

## 5.31 nextTick 使用场景和原理

nextTick 中的回调是在下次 DOM 更新循环结束之后执行的延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。主要思路就是采用微任务优先的方式调用异步方法去执行 nextTick 包装的方法。

## 5.32 keep-alive 使用场景和原理

keep-alive 是 Vue 内置的一个组件，可以实现组件缓存，当组件切换时不会对当前组件进行卸载。

- 常用的两个属性 include/exclude，允许组件有条件的进行缓存。
- 两个生命周期 activated/deactivated，用来得知当前组件是否处于活跃状态。
- keep-alive 的中还运用了 LRU(最近最少使用) 算法 （超过 keep-alive 最大的保存长度就会删除），选择最近最久未使用的组件予以淘汰。

## 5.33 Vue.set 方法原理

了解 Vue 响应式原理的同学都知道在两种情况下修改数据 Vue 是不会触发视图更新的

1.在实例创建之后添加新的属性到实例上（给响应式对象新增属性）

2.直接更改数组下标来修改数组的值

Vue.set 或者说是$set 原理如下

因为响应式数据 我们给对象和数组本身都增加了**ob**属性，代表的是 Observer 实例。当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪 然后会触发对象**ob**的 dep 收集到的 watcher 去更新，当修改数组索引时我们调用数组本身的 splice 方法去更新数组

## 5.34 Vue.extend 作用和原理

官方解释：Vue.extend 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。

其实就是一个子类构造器 是 Vue 组件的核心 api 实现思路就是使用原型继承的方法返回了 Vue 的子类 并且利用 mergeOptions 把传入组件的 options 和父类的 options 进行了合并

## 5.35 写过自定义指令吗 原理是什么

指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素增加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。

自定义指令有五个生命周期（也叫钩子函数），分别是 bind、inserted、update、componentUpdated、unbind

\1. bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。 2. inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。 3. update：被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。 4. componentUpdated：被绑定元素所在模板完成一次更新周期时调用。 5. unbind：只调用一次，指令与元素解绑时调用。

**原理**

1.在生成 ast 语法树时，遇到指令会给当前元素添加 directives 属性

2.通过 genDirectives 生成指令代码

3.在 patch 前将指令的钩子提取到 cbs 中,在 patch 过程中调用对应的钩子

4.当执行指令对应钩子函数时，调用对应指令定义的方法

## 5.36 Vue 修饰符有哪些

**事件修饰符**

- .stop 阻止事件继续传播
- .prevent 阻止标签默认行为
- .capture 使用事件捕获模式,即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理
- .self 只当在 event.target 是当前元素自身时触发处理函数
- .once 事件将只会触发一次
- .passive 告诉浏览器你不想阻止事件的默认行为

**v-model 的修饰符**

- .lazy 通过这个修饰符，转变为在 change 事件再同步
- .number 自动将用户的输入值转化为数值类型
- .trim 自动过滤用户输入的首尾空格

**键盘事件的修饰符**

- .enter
- .tab
- .delete (捕获“删除”和“退格”键)
- .esc
- .space
- .up
- .down
- .left
- .right

**系统修饰键**

- .ctrl
- .alt
- .shift
- .meta

**鼠标按钮修饰符**

- .left
- .right
- .middle

## 5.37 Vue 模板编译原理

Vue 的编译过程就是将 template 转化为 render 函数的过程 分为以下三步：

第一步是将 模板字符串 转换成 element ASTs（解析器）

第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）

第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）

## 5.38 能说下 vue-router 中常用的路由模式实现原理吗

vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：

```
switch (mode) {
  case 'history':
	this.history = new HTML5History(this, options.base)
	break
  case 'hash':
	this.history = new HashHistory(this, options.base, this.fallback)
	break
  case 'abstract':
	this.history = new AbstractHistory(this, options.base)
	break
  default:
	if (process.env.NODE_ENV !== 'production') {
	  assert(false, `invalid mode: ${mode}`)
	}
}
复制代码
```

其中，3 种路由模式的说明如下：

- hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；
- history : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；
- abstract : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.

**hash 模式**

1. location.hash 的值实际就是 URL 中#后面的东西 它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
2. 可以为 hash 的改变添加监听事件

```javascript
window.addEventListener("hashchange", funcRef, false);
复制代码;
```

每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了

> 特点：兼容性好但是不美观

**history 模式**

利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。

这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会刷新页面，这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。

## 5.39 vue3.0 特性你有什么了解的吗？

- 响应式原理的改变 Vue3.x 使用 Proxy 取代 Vue2.x 版本的 Object.defineProperty
- 组件选项声明方式 Vue3.x 使用 Composition API setup 是 Vue3.x 新增的一个选项， 他是组件内使用 Composition API 的入口。
- 模板语法变化 slot 具名插槽语法 自定义指令 v-model 升级
- 其它方面的更改 Suspense 支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。 基于 treeshaking 优化，提供了更多的内置功能。

Vue3.0 新特性以及使用经验总结 [传送门](https://juejin.cn/post/6940454764421316644)

## 5.40 说说你对 SPA 单页面的理解，它的优缺点分别是什么？

SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。

**优点：**

- 用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
- 基于上面一点，SPA 相对对服务器压力小；
- 前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

- 初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
- 前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
- SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。

## 5.41 `$route`和`$router`的区别

- $route 是`路由信息对象`，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。
- 而$router 是`路由实例`对象包括了路由的跳转方法，钩子函数等。

## 5.42 vue-router 路由懒加载

像 vue 这种单页面应用，如果没有路由懒加载，运用 webpack 打包后的文件将会很大，造成进入首页时，需要加载的内容过多，出现较长时间的白屏，运用路由懒加载则可以将页面进行划分，需要的时候才加载页面，可以有效的分担首页所承担的加载压力，减少首页加载用时。

- 参考: [vue 路由懒加载](https://juejin.cn/post/6895546761255845901#heading-4)

vue 路由懒加载有以下三种方式：

1. vue 异步组件
2. ES6 的 import()
3. webpack 的 require.ensure()

## 5.43 Vue Diff 算法？

参考: https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9e3c68d1b0884d9ca0f8ffc5ee64a28e~tplv-k3u1fbpfcp-watermark.awebp

参考: https://juejin.cn/post/6953433215218483236

## 5.44 如何使用 v-model 封装自定义组件或者 UI 组件？（二次封装）

参考: https://www.jianshu.com/p/f288b27171b3

# 六、项目内容

## 6.1 Vue 项目的难点有哪些？

## 6.2 Vue 项目上线之前做了哪些优化？

## 6.3 uniapp 项目的难点有哪些？

## 6.4 uniapp 项目上线之前做了哪些优化？

https://juejin.cn/post/6997224351346982942

## 6.5 Webpack 有哪些优化手段

参考： https://juejin.cn/post/6844904093463347208

## 6.6 babel 是什么，原理了解吗

Babel 是一个 JavaScript 编译器。他把最新版的 javascript 编译成当下可以执行的版本，简言之，利用 babel 就可以让我们在当前的项目中随意的使用这些新最新的 es6，甚至 es7 的语法。

Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。

- 解析 将代码解析成抽象语法树（AST），每个 js 引擎（比如 Chrome 浏览器中的 V8 引擎）都有自己的 AST 解析器，而 Babel 是通过 Babylon 实现的。在解析过程中有两个阶段：词法分析和语法分析，词法分析阶段把字符串形式的代码转换为令牌（tokens）流，令牌类似于 AST 中节点；而语法分析阶段则会把一个令牌流转换成 AST 的形式，同时这个阶段会把令牌中的信息转换成 AST 的表述结构。
- 转换 在这个阶段，Babel 接受得到 AST 并通过 babel-traverse 对其进行深度优先遍历，在此过程中对节点进行添加、更新及移除操作。这部分也是 Babel 插件介入工作的部分。
- 生成 将经过转换的 AST 通过 babel-generator 再转换成 js 代码，过程就是深度优先遍历整个 AST，然后构建可以表示转换后代码的字符串。

还想深入了解的可以看 [[实践系列\]Babel 原理](https://juejin.cn/post/6844903760603398151)

# 七、设计模式

## 7.1 观察者模式、发布-订阅模式篇

```javascript
/**
 * @description 观察者模式实现
 */
// 目标对象
class Subject {
    constructor() {
        // 维护一个观察者集合
        this.observerList = [];
    }
    // 添加观察者
    addObserver(observer) {
        // 避免重复添加观察者
        if(this.observerList.includes(observer)) return;
        this.observerList.push(observer);
    }
    // 删除指定观察者，不支持全部删除，风险较高
    removeObserver(observer) {
        if(!observer) return;
        this.observerList = this.observerList.filter(i => i !== observer);
    }
    // 通知观察者
    notify() {
        // 若无观察者，也就不通知了
        if(!this.observerList) return;
        // 遍历调用观察者的 update 方法
        this.observerList.forEach(observer => {
            if(observer.update && Object.prototype.toString.call(observer.update).slice(8, -1) === "Function") {
                observer.update();
            }
        });
    }
}
// 观察者
class Observer {
    update() {
        console.log("我观察到了目标对象的变化");
    }
}

作者：博小魏
链接：https://juejin.cn/post/7035247560918990884
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 7.2 单例模式

顾名思义单例就是多次执行都只会生成这一个对象。

参考地址: https://blog.csdn.net/loringray/article/details/104585104

## 7.3 工厂模式

参考: https://segmentfault.com/a/1190000012422198

# 八、Typescript

## 8.1 ts 中的访问修饰符

- public，任何地方
- private，只能在类的内部访问
- protected，能在类的内部访问和子类中访问
- readonly，属性设置为只读

## 8.2 const 和 readonly 的区别

- const 用于变量，readonly 用于属性

- const 在运行时检查，readonly 在编译时检查

- 使用 const 变量保存的数组，可以使用 push，pop 等方法。但是如果使用`ReadonlyArray<number>`声明的数组不能使用 push，pop 等方法。

## 8.3 枚举和常量枚举（const 枚举）的区别

1. 枚举会被编译时会编译成一个对象，可以被当作对象使用

2. const 枚举会在 ts 编译期间被删除，避免额外的性能开销

   ```typescript
   // 普通枚举
   enum Witcher {
     Ciri = "Queen",
     Geralt = "Geralt of Rivia",
   }
   function getGeraltMessage(arg: { [key: string]: string }): string {
     return arg.Geralt;
   }
   getGeraltMessage(Witcher); // Geralt of Rivia

   // const枚举
   const enum Witcher {
     Ciri = "Queen",
     Geralt = "Geralt of Rivia",
   }
   const witchers: Witcher[] = [Witcher.Ciri, Witcher.Geralt];
   // 编译后
   // const witchers = ['Queen', 'Geralt of Rivia'
   ```

## 8.4 ts 中 interface 可以给 Function/Array/Class 做声明吗？

可以的

## 8.5 ts 中的 this 和 js 中的 this 有什么差异？

## 8.6 ts 中如何枚举联合类型的 key?

```typescript
type Name = { name: string };
type Age = { age: number };
type Union = Name | Age;

type UnionKey<P> = P extends infer P ? keyof P : never;

type T = UnionKey<Union>;
```

## 8.7 ts 中 ?.、??、!.、\_、\*\* 等符号的含义？

?. 可选链

?? ?? 类似与短路或，??避免了一些意外情况 0，NaN 以及"",false 被视为 false 值。只有 undefind,null 被视为 false 值。

!. 在变量名后添加!，可以断言排除 undefined 和 null 类型

\_ , 声明该函数将被传递一个参数，但您并不关心它

\*\* 求幂

!:，待会分配这个变量，ts 不要担心

```typescript
// ??
let x = foo ?? bar();
// 等价于
let x = foo !== null && foo !== undefined ? foo : bar();

// !.
let a: string | null | undefined
a.length // error
a!.length // ok

作者：dyhtps
链接：https://juejin.cn/post/6988763249982308382
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 8.8 什么是抗变、双变、协变和逆变？

Covariant 协变，TS 对象兼容性是协变，父类 <= 子类，是可以的。子类 <= 父类，错误。

Contravariant 逆变，禁用`strictFunctionTypes`编译，函数参数类型是逆变的，父类 <= 子类，是错误。子类 <= 父类，是可以的。

Bivariant 双向协变，函数参数的类型默认是双向协变的。父类 <= 子类，是可以的。子类 <= 父类，是可以的。

## 8.9 ts 中同名的 interface 或者同名的 interface 和 class 可以合并吗？

1.  interface 会合并
2.  class 不可以合并

## 8.10 如何使 ts 项目引入并识别编译为 js 的 npm 库包？

1.  `npm install @types/xxxx`
2.  自己添加描述文件

## 8.11 ts 如何自动生成库包的声明文件？

可以配置`tsconfig.json`文件中的`declaration`和`outDir`

1.  declaration: true, 将会自动生成声明文件
2.  outDir: '', 指定目录

## 8.12 什么是泛型

泛型用来来创建可重用的组件，一个组件可以支持多种类型的数据。这样用户就可以以自己的数据类型来使用组件。**简单的说，“泛型就是把类型当成参数”。**

## 8.13 -?，-readonly 是什么含义

用于删除修饰符

```typescript
type A = {
    a: string;
    b: number;
}

type B = {
    [K in keyof A]?: A[K]
}

type C = {
    [K in keyof B]-?: B[K]
}

type D = {
    readonly [K in keyof A]: A[K]
}

type E = {
    -readonly [K in keyof A]: A[K]
}

作者：dyhtps
链接：https://juejin.cn/post/6988763249982308382
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 8.14 TS 是基于结构类型兼容

typescript 的类型兼容是基于结构的，不是基于名义的。下面的代码在 ts 中是完全可以的，但在 java 等基于名义的语言则会抛错。

```typ
interface Named { name: string }
class Person {
  name: string
}
let p: Named
// ok
p = new Person()
```

## 8.15 const 断言

const 断言，typescript 会为变量添加一个自身的字面量类型

1.  对象字面量的属性，获得 readonly 的属性，成为只读属性
2.  数组字面量成为 readonly tuple 只读元组
3.  字面量类型不能被扩展（比如从 hello 类型到 string 类型）

```typescript
// type '"hello"'
let x = "hello" as const
// type 'readonly [10, 20]'
let y = [10, 20] as const
// type '{ readonly text: "hello" }'
let z = { text: "hello" } as const

作者：dyhtps
链接：https://juejin.cn/post/6988763249982308382
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 8.16 type 和 interface 的区别

1.  类型别名可以为任何类型引入名称。例如基本类型，联合类型等
2.  类型别名不支持继承
3.  类型别名不会创建一个真正的名字
4.  类型别名无法被实现(implements)，而接口可以被派生类实现
5.  类型别名重名时编译器会抛出错误，接口重名时会产生合并

## 8.17 implements 与 extends 的区别

- extends, 子类会继承父类的所有属性和方法。
- implements，使用 implements 关键字的类将需要实现需要实现的类的所有属性和方法。

## 8.18 枚举和 object 的区别

枚举可以通过枚举的名称，获取枚举的值。也可以通过枚举的值获取枚举的名称。

object 只能通过 key 获取 value

数字枚举在不指定初始值的情况下，枚举值会从 0 开始递增。

虽然在运行时，枚举是一个真实存在的对象。但是使用 keyof 时的行为却和普通对象不一致。必须使用 keyof typeof 才可以获取枚举所有属性名。

## 8.19 never, void 的区别

never，never 表示永远不存在的类型。比如一个函数总是抛出错误，而没有返回值。或者一个函数内部有死循环，永远不会有返回值。函数的返回值就是 never 类型。

void, 没有显示的返回值的函数返回值为 void 类型。如果一个变量为 void 类型，只能赋予 undefined 或者 null。

## 8.20 unknown, any 的区别

unknown 类型和 any 类型类似。与 any 类型不同的是。unknown 类型可以接受任意类型赋值，但是 unknown 类型赋值给其他类型前，必须被断言

## 8.21 如何在 window 扩展类型

```typescript
declare global {
  interface Window {
    myCustomFn: () => void;
  }
}
```

## 8.22 元祖越界问题

```typescript
let aaa: [string, number] = ["aaa", 5];
// 添加时不会报错
aaa.push(6);
// 打印整个元祖不会报错
console.log(aaa); // ['aaa',5,6];
// 打印添加的元素时会报错
console.log(aaa[2]); // error
```

## 8.23 重写(override) vs 重载(overload)

- **重写是指子类重写“\*\*\*\*继承\*\*\*\*”自父类中的方法** 。虽然 TS 和 JAVA 相似，但是 TS 中的继承本质上还是 JS 的“**继承**”机制—**原型链机制**

- **重载是指为同一个函数提供多个类型定义**

  ```typescript
  class Animal {
    speak(word: string): string {
      return "动作叫:" + word;
    }
  }

  class Cat extends Animal {
    speak(word: string): string {
      return "猫叫:" + word;
    }
  }

  let cat = new Cat();
  console.log(cat.speak("hello"));

  /**--------------------------------------------**/

  function double(val: number): number;
  function double(val: string): string;
  function double(val: any): any {
    if (typeof val == "number") {
      return val * 2;
    }
    return val + val;
  }

  let r = double(1);
  console.log(r);
  ```

## 8.24 ts 常见问题

     https://juejin.cn/post/6929038446837104647

# 九、微信小程序

## 9.1 小程序的双向绑定和 vue 哪里不一样?

小程序直接 this.data 的属性是不可以同步到视图的，必须调用：

```
this.setData({
    // 这里设置
})
```

## 9.2 小程序页面间有哪些传递数据的方法?

- **使用全局变量实现数据传递**

- **使用 wx.navigateTo 与 wx.redirectTo 的时候，可以将部分数据放在 url 里面，并在新页面 onLoad 的时候初始化**

- **使用本地缓存**

  ## 9.3 小程序页面的生命周期函数 及其 App 生命周期函数

**页面生命周期：**

onLoad 页面加载时触发。一个页面只会调用一次，可以在 onLoad 的参数中获取打开当前页面路径中的参数

onShow() 页面显示/切入前台时触发

onReady() 页面初次渲染完成时触发。一个页面只会调用一次，代表页面已经准备妥当，可以和视图层进行交互

onHide() 页面隐藏/切入后台时触发。 如 navigateTo 或底部 tab 切换到其他页面，小程序切入后台等

onUnload() 页面卸载时触发。如 redirectTo 或 navigateBack 到其他页面时

**APP 生命周期:**

- onLaunch() 监听小程序初始化 当小程序初始化完成时，会触发 onLaunch（全局只触发一次）
- onShow() 监听小程序显示 当小程序启动，或从后台进入前台显示，会触发 onShow
- onHide() 监听小程序隐藏 当小程序从前台进入后台，会触发 onHide
- onError() 错误监听函数 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息

## 9.4 微信小程序的优劣势

**优势**

- 即用即走，不用安装，省流量，省安装时间，不占用桌面
- 依托微信流量，天生推广传播优势
- 开发成本比 App 低

**缺点**

- 用户留存，即用即走是优势，也存在一些问题
- 入口相对传统 App 要深很多
- 限制较多,页面大小不能超过 2M。不能打开超过 10 个层级的页面

## 9.5 **如何实现下拉刷新**

首先在全局 config 中的 window 配置 enablePullDownRefresh
在 Page 中定义 onPullDownRefresh 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法
请求返回后，调用 wx.stopPullDownRefresh 停止下拉刷新

## 9.6 bindtap 和 catchtap 的区别是什么?

**相同点**：首先他们都是作为点击事件函数，就是点击时触发。在这个作用上他们是一样的，可以不做区分
**不同点**：他们的不同点主要是 bindtap 是不会阻止冒泡事件的，catchtap 是阻止冒泡的

## 9.7 简述下 wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()的区别?

wx.navigateTo()：保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面 wx.redirectTo()：关闭当前页面，跳转到新的页面（类似重定向）。但是不允许跳转到 tabbar 页面
wx.switchTab()：跳转到 tabBar 页面，并关闭其他所有非 tabBar 页面
wx.navigateBack():关闭当前页面，返回上一页面或多级页面。可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层
wx.reLaunch()：关闭所有页面，打开到应用内的某个页面

## 9.8 **登录流程？**

登录流程是调 wx.login 获取 code 传给后台服务器获取微信用户唯一标识 openid 及本次登录的会话密钥（session_key、token）等）。拿到开发者服务器传回来的会话密钥（session_key、token）之后，前端要保存 wx.setStorageSync('sessionKey', 'value')或者 wx.setStorageSync('token', 'value')

持久登录状态：session 或者 token 信息存放在 cookie 或者 header 的 Authorization 中以请求头的方式带回给服务端，放到 request.js 里的 wx.request 的 header 里。

## 9.9 小程序父子组件之间的传参？

父向子: props

子向父: triggerEvent

## 9.10 哪些方法可以用来提高微信小程序的应用速度？

1、提高页面加载速度

2、用户行为预测

3、减少默认 `data` 的大小

4、组件化方案

5、分包

## 9.11 小程序支付的流程？

- 1.  打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单
- 2.  如果用户没有登录，则跳转登录页面或者弹出登录窗口，需要点击一键登录，登录流程过程跳转到之前的下单页面
- 3. 登录完成后需要将小明购买的商品 Id，商品数量，以及小明这个用户的 Token 传送到服务器，进行创建订单
- 4. 服务器在接收到商品 Id、商品数量、openId 后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)
- ​ 5. 小程序端在获取对应的参数后，调用 wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付

  具体参数:

```javascript
// 时间戳  timeStamp: '',

// 随机字符串  nonceStr: '',

// 统一下单接口返回的 prepay_id 参数值  package: '',

// 签名类型  signType: '',

// 签名  paySign: ''
```
