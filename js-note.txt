        1.git
            github:一个代码的分享网站。类似facebook。可以上传、下载代码，搜索代码，设置隐私权限，查看历史等。
            gitee:国内版的github,类似微信。
            git:负责本地把本地代码和 gitee 关联的桥梁。
            因此:本机又称本地，远程又称云端。
            git: 代码的管理工具，可以和同事一起开发同一个项目。有同步、提交、查看历史、回退等功能。
 
            git 分4个工作区域:  
            1. 工作目录 (Working Directory) 
            2. 暂存区 (Stage/index)
            3. 资源库/本地仓库 (Repository/ Git Directory)   
            4. 远程仓库(云端仓库) (Remote Directory)
            转化关系:     
                工作目录 ——git add files——> 暂存区  ——git commit——> 本地仓库  ——git push——> 远程仓库
                远程仓库 ——git pull——>  本地仓库  ——git reset——> 暂存区  ——git chcekout——> 工作目录
            
                注意：
                1. 工作目录 暂存区 资源库,都在本机，远程仓库在云端。 
                2. 介绍:
                    工作目录:工作区，平时存放代码的地方。或者代码刚开始被 git 接管。
                    暂存区:记录临时存放改动。
                    本地仓库: 安全存储数据的位置，有所有版本的信息，其中 HEAD 指向最新的放入的仓库版本。
                    远程仓库:远程存储代码的仓库。

            初始化本地仓库: git init

            版本的命名规范：12.34.11
                12：大版本号
                34：增加新功能
                11：修复bug

            网络并发
            语言的发展：
                高性能：
                高可用：
                高并发：
            写代码的要求：可读性强。
                信息的传输速度不能大于信道宽度
            
            C语言  驱动硬件
            js  代码运行在浏览器中
            js  如何满足高性能、高可用、高并发
                JS在网页中运行时单线程模式, 在服务端nodejs中运行是单进程模式, 都无法像JAVA那样开启多个线程或者协程来处理高并发任务.
                JS处理高并发场景使用的是 : 队列机制, 事件机制

            ### 分支命令
            命令|解释
            ---|---
            git log | 查看提交日志
            git branch | 查看分支
            git branch -a | 查看所有分支操作
            git branch dev |创建分支 dev
            git checkout dev |切换至分支 dev
            git merge dev master | merge branch 'master' into dev
            git merge dev | 把 dev 合并到当前分支
            ```
            git push origin -delete dev |  删除远程分支dev
            git branch –D dev | 删除本地未合并的分支dev
            git branch –d dev | 删除本地已经合并了的分支dev


            //一般先切换至 master 分支
            git checkout master
            //再合并分支
            git merge dev

            git 不能提交空文件夹，必须在文件夹里新建一个文件 .gitkeep

        2.绪论
            计算机：做重复性的工作
            编程：告诉计算机做哪些
            计算机的本质是  二进制
                位  0  1
                字节     byte    8
                千字节   kb      1024 * 8
                兆字节   mb      1024 * 1024 * 8
                吉字节   gb      1024 * 1024 * 1024 * 8

                ascii 码
                2 ^ 8 = 256
                0-127  键盘上的每一个键，都有对应的数字
                
                936  简体中文
                65001  utf-8  进行了大一统

            js语言是运行在浏览器中的
            语言的差别：h5 css js java php C python
                java python        侧重处理数据
                js                 侧重渲染数据
            什么是js？
                后台获取数据，根据具体的逻辑，进行渲染数据

            翻译器（执行引擎）：把当前代码，翻译成计算机可以识别的语言
            输入、处理、输出
            约定大于规范，规范大于编码

        3.js代码书写
            ①行内书写： onclick="alert('清理成功')"
            ②在body书写
            ③在head外部引入 <script src="demo.js"></script>

        4.注释
            //单行注释   ctrl+/
            /* 
                多行注释   ctrl+shift+/
            */
            // todo   需要做的事情，等待完成

        5.输入输出语句
            弹出提示框    alert("");
            弹出确认框    confirm("");
            控制台输出    console.log("");
                //可以传入多个数据，用逗号切割 console.log(a,b);
            打印输出到浏览器   document.write();
                //不建议使用
                //文档在加载的过程中实际上就是一边加载一边用document.write写出内容到屏幕上
            提示用户输入  prompt("");
                //用于用户交互，接收用户输入的值
                //var age = prompt("请输入你的年龄");

        6.变量（variable）
            存储单个数据的容器
            本质：变量是程序在内存中申请的一块用来存放数据的空间
            特点：先声明，后使用
            1.关键字 var 声明变量
            2."="  赋值  将后面的值，给前面的变量名 
                var age = 19;
            3.变量参与操作的时候，实际是值进行了操作
                值可以进行覆盖
            4.let 关键字声明 （注意：变量名不能重复）

            5.只声明，未赋值的变量是 undefined
            6.可以不声明直接赋值使用
                a=10;//不推荐使用

            7.可以同时声明多个变量
                var age = 22,
                    score = 99;//不推荐使用，可读性不强

            ###变量命名规范
                1.由字母、数字、下划线、$组成
                2.严格区分大小写
                3.不能以数字开头
                4.不能是关键字、保留字，变量名必须有意义，使用英语，不要拼音
                5.遵守驼峰命名法（首字母小写，后面单词首字母大写。如：myFirstName）
                6.name 已被系统占用

        7.数据类型
            简单数据类型（Number,String,Boolean,Undefined,Null）把值直接存在栈内
            复杂数据类型（object）把值存在对应的地址中

            简单数据类型      说明                                默认值

            Number          数字型，包含整型和浮点型                 0
                        //数字型的最大值  Number.MAX_VALUE
                        //数字型的最小值  Number.MIN_VALUE
                        //infinity 无穷大  Number.MAX_VALUE * 2
                        //-infinity 无穷小
                        //NaN 非数字
                        //isNaN() 判断非数字  是数字返回false

            Boolean         布尔值类型（true/false）               false
                        //和数字型相加，true为1，false为0

            String          字符串类型                              ""
                        // \n   换行符
                        // \\   斜杠
                        // \'   单引号  \"  双引号
                        // \t   tab 缩进
                        // \b   空格 

            Undefined       var a;声明变量a没有给值               undefined
                        //与字符串相加 +"aa" 为 "undefinedaa"
                        //与数字相加  NaN

            Null            var a = null;声明变量a为空值            null
                        //与字符串相加 +"aa" 为 "nulldaa"
                        //与数字相加  结果为数字的值
            
            ### typeof  检测数据类型
                length  获取字符串的长度

        8.常量
            常量：不变化的量
            const 声明
            常量名全部用大写
                const PI =3.14;
                console.log(PI);

            字符串：引号
                1.模板字符串 ``
                    模板字符串可以用来解析变量
                    模板字符串中嵌入变量，要将变量名写在${}之中。
                2.特殊字符，用转义符
                3.length 获取字符串的长度
                4.+ 可以进行字符串的拼接
                5.字符串拼接其它数据类型后还是字符串
                6.字符串和变量拼接：引引加加

            ### js中三种定义变量的方式 const， var， let的区别：
                1.const定义的变量不可以修改，而且必须初始化。
                    const b;//错误，必须初始化
                    const b = 2;//正确
                    const b = 5;//错误，不能覆盖修改，already been declared
                    b = 5;//错误，Uncaught TypeError
                2.var定义的变量可以修改，如果不初始化会输出undefined，不会报错。只有函数作用域，无块级作用域
                3.let是块级作用域，函数内部使用let定义后，对函数外部无影响。
                    function letTest() {
                        let x = 1;
                        if (true) {
                            let x = 2;  // 不同的变量
                            console.log(x);  // 2
                        }
                        console.log(x);  // 1
                    }
                注意：let和const都是es5，es6新版本的js语言规范出来的定义
                    let是块级别（大括号括起来的内容）
                    const声明的变量只可以在声明时赋值，不可随意修改，不能修改的是栈内存在的值和地址
                    var 在全局级别（在函数外部）进行声明都会自动成为 window 对象上的一个属性：
                        var name = 'Johnson';
                        window.name === name // true
                    https://blog.csdn.net/qq_42539194/article/details/113920185

        9.字面量：见名知义
            1.number 纯数字
            2.字符串 加引号
            3.布尔值 true false
            4.未赋值 undefined
            5.null 下一次垃圾回收的时候，清理内存
        
        10.数据转换
            1.转换为字符串型
                toString()
                String()
                加号拼接

                //prompt() 接收的数据作为字符串
                let temp=prompt('请输入一句话');
                console.log(typeof temp);//string

            2.转换为数字型
                parseInt(string)函数
                parseFloat(string)函数
                Number()强制转换函数
                js隐式转换(- * /) 利用算术运算隐式转换为数值型

            3.转换为布尔型
                Boolean()函数
                    ''，0，NaN，null，undefined 转化结果都为false

        11.算术运算符
            let num = 22;
            // 1. 模运算，取余
            console.log(num % 5);

            // 2. 精度失真 ：计算机的本质是二进制，
            //计算时需要转化为二进制，再进行算术运算，结果转化为十进制。
            console.log(7 * 100);
            console.log(0.1 + 0.2);
            console.log(0.07 * 100);

            // 3. number 16位
            console.log(12345678901234567890);
                    
            // 4. digdecimal decimal

            // 5. toFixed() 保留几位小数 四舍五入
            console.log((0.1+0.2).toFixed(1));

        12.表达式
            由 数字、运算符、变量等 以能求得数值的 有意义 排列方法 所得的组合。
            即 由数字、运算符、变量等组成的式子。
            //有一个结果，结果成为返回值

            ### 表达式分类
                单值表达式：不使用运算符的表达式
                    简单表达式：不能再分解的表达式
                    复杂表达式：需要其它表达式参与的表达式
                复合表达式：由运算符将多个单值表达式结合而成的表达式
                (所有表达式均有返回值)
                https://www.cnblogs.com/fangsmile/p/8337021.html

        13.自增自减
            // 自增运算符 ：自加以后，重新赋值给自己
                // ++num; 前置运算符
                // num++; 后置运算符
            // 自减运算符 ：自减以后，重新赋值给自己
                // --num; 前置运算符
                // num--; 后置运算符
            前置自增自减：先自增自减运算，后表达式运算
            后置自增自减：先表达式运算，后自增自减云算

        14.比较运算符
            1. 比较运算符 ：>  <  ==  ===  !=  >=  <=
            2. 返回值是 布尔值
            3. == 由隐式转化的过程
            4. === 比较值和数据类型
            5. 学习的一个原则
                输入 ：表达式
                处理 ：运算符
                输出 ：结果

        15.逻辑运算符 ：
            1. &&  与  and 
            2. ||  或  or
            3. !   非  not

            输入 ：布尔值
            输出 ：与或非
            输出 ：布尔值

            // 与运算：只要有一个是 false，则结果是false
            console.log(true && true); //true
            // 或运算：只要有一个是 true，则结果是true
            console.log(true || false); //true
            // 非 ：取反
            console.log(!true);  // false
            console.log(!false);

        16.短路运算符 ：
            1. && 短路与：(全真则真)
                如果 第1个数 是 false 或者可以转换成 false，则结果就是第一个数。
                如果 第1个数 是 true 或者可以转换成 true， 则结果就是第二个数。
                    console.log(3 > 2 && 4 + 2);  // 6
                    console.log(3 < 2 && 4 + 2);  // false
            2. || 短路或：(有真即真)
                如果 第1个数 是 true 或者可以转换成 true，则结果就是第一个数。
                如果 第1个数 是 fasle 或者可以转换成 false， 则结果就是第二个数。
                注意：当某个属性或某个值为null、undefined、false、0、空字符串""时，结果是||后面的值
                    console.log(3 > 2 || 4 + 2);  // true
                    console.log(3 > 2 || 4 + 2);  // 6
            3. 特殊情况：空指针
                    console.log(null && 2 + 5);  // null
                    console.log(2<5 && null);  // null
                    console.log(2>5 && null);  // false
                    console.log(null || 2+5);  // 7
                    console.log(2<5 || null);  // true
                    console.log(2>5 || null);  // null

                ??运算符：当某个属性或某个值为null或undefined时，取??后面的值

            注意：
                1，如果返回表达式1，则表达式2不再参与运算
                2. 表达式1的值会转化为布尔值，再参与短路运算

        17.赋值运算符：把数据赋值给变量的符号
            1. = 赋值，把后面的值赋值给前面的变量
            2. += -= *= /= 

        18.运算符优先级：
            1. ()
            2. 单目运算符  ++ --
            3. 算术运算符  + - * / % (先乘除后加减)
            4. 比较运算符  > < >= <= != == ===
            5. 逻辑运算符  && || (先 && 后 ||)
            6. 三目运算符  ?   :   (了解即可)
            7. 赋值运算符 = += -= *= /=

            技巧：一般通过逻辑运算符分割

        19.流程控制：
            1. 顺序执行 ：从上往下执行代码
            2. 分支 ：根据不同的情况，执行不同的代码
            3. 循环 ：重复执行某些代码

            debug ：F12 ————> 来源
                作用 ：调试代码
                断点 ：鼠标在左侧点击即可，调试代码停止的位置
                F5 ——> F9 ：下一行代码
                控制台输出 变量

        20.分支语句 ：根据不同的条件，执行不同的代码
            语法结构 ：
                if (条件判断) {
                    代码逻辑
                }
            执行顺序 : 1. 条件判断
                       2.1 true 执行代码逻辑
                       2.2 false 跳出整个代码块

        21.双分支 ：
            语法结构 ：
                if (条件判断) {
                    逻辑体1;
                }else{
                    逻辑体2;
                }
            执行顺序 ：
                1.条件判断
                2.1 true 执行逻辑体1
                2.2 false 执行逻辑体2
            只能选择一个

            ###闰年：
                普通闰年：公历年份是4的倍数，且不是100的倍数的，为闰年（如2004年、2020年等就是闰年）。
                世纪闰年：公历年份是整百数的，必须是400的倍数才是闰年（如1900年不是闰年，2000年是闰年）。
            总结:
                % 取余
                && ||
                ()
                if   else

                let year = prompt('请输入年份');

                if ((year % 4 == 0) && (year % 100 != 0) || (year % 100 == 0) && (year % 400 == 0)) {
                    console.log(`${year}是闰年`);
                } else {
                    console.log(`${year}是平年，2月份有28天`);
                }

        22.多分支：
            语法结构: 
                if (布尔值1) {
                    逻辑体1;
                } else if (布尔值2) {
                    逻辑体2;
                } else if (布尔值3) {
                    逻辑体3;
                } else {
                    逻辑体x;
                }
            执行顺序: 
                1. 布尔值1，如果是 true，执行逻辑体1.跳出整个代码块。
                2. 布尔值1，如果是 false，判断布尔值2.
                3. 布尔值2，如果是 true，执行逻辑体2.跳出整个代码块。
                4. 布尔值2，如果是 false，判断布尔值3.
                ...
                x. 如果布尔值都是false，则执行逻辑体x。
            
            总结: 
                1. 只能选择其中的一个条件触发。    
                2. 可读性。
                3. 计算机的性能更高

        23.三元表达式 ：有三个运算符组成的式子
            语法结构 ：
                条件判断 ？表达式1 ：表达式2
            执行顺序 ：
                1. 条件判断
                2.1 true 表达式1的值返回
                2.1 false 表达式2的值返回

        24.Switch
            switch 交换，开关   case 案例   break 打破   default 默认
            语法结构
                switch (表达式){
                    case value1 :
                        逻辑体1;
                        break;
                    case value2 :
                        逻辑体2;
                        break;
                    case value3 :
                        逻辑体3;
                        break;
                        ...
                    default :
                        逻辑体x;
                }
            执行顺序 ：
                value 和 value1 ，如果相等，则执行 逻辑体1;跳出整个代码块
                如果不相等
                value 和 value2 ，如果相等，则执行 逻辑体2;跳出整个代码块
                如果不相等
                ...
                如果和 case 的 value 都不相等，则执行 default 的逻辑体x，跳出代码块

            总结：
                1. 遇到 break，跳出整个代码块
                2. value 的比较是 ===

        25.for 循环
            语法结构
                for (初始化条件; 判断条件; 变化条件){
                    循环体;
                }
            循环的四要素：
                1. 初始化条件 ：声明一个变量，用做计数器
                2. 判断条件 ：决定是否进行循环
                3. 变化条件 ： 作为计数器的终点
                4. 循环体 ：每次循环执行的代码
            执行顺序 ：
                1. 初始化条件
                2. 条件判断
                3.1 true 逻辑体
                3.2 false 跳出代码块
                4. 变化条件
                5. 2 3 4 重复执行
            let 声明的变量只在代码块中可以使用

            ### 优化 for 循环
                for(j=0,len=arr.length;j<len;j++){
                console.log(arr[j]);
            }

            ###打印小星星
                /*
                    * 
                    **
                    ***
                    ****
                    *****
                */
                for (let i = 0; i < 5; i++) {
                    var star1 = "";
                    for (let j = 0; j <= i; j++) {
                        star1 = star1 + "*";
                    }
                    console.log(star1);
                }
                /*
                        *
                       **
                      ***
                     ****
                    ***** 
                */
                for (let i = 0; i < 5; i++) {
                    var star2 = "";
                    for (let j = 0; j < 5 - i; j++) {
                        star2 = " " + star2;
                    }
                    for (let k = 0; k <= i; k++) {
                        star2 = star2 + "*";
                    }
                    console.log(star2);
                }

            ###九九乘法表
                for (let i = 1; i <= 9; i++) {
                    let star = '';
                    for (let j = 1; j <= i; j++) {
                        let sum = i * j;
                        sum = sum < 10 ? sum + ' ' : sum;
                        star = star + (`${j}×${i}=${sum}  `);
                    }
                    console.log(star);
                }
        
            ###js 中的 4 种 for 循环
                https://www.cnblogs.com/lynn-z/p/13068866.html

        26.while 循环 while 当 ... 的时候
            语法结构：
            while (条件判断){
                逻辑体;
            }
            执行顺序：
                1. 初始化条件
                2. 条件判断
                3.1 true 逻辑体
                3.2 false 跳出整个代码块
                4. 重复2、3、4
            重点：一定要写变化条件，防止死循环

        27.do —— while
            语法结构：
                do {
                    逻辑体;
                } while (判断条件);
            执行顺序：
                1. 初始化变量
                2. 执行逻辑体
                3. 判断条件
                4.1 true  2、3、4步骤
                4.2 false 跳出整个代码块
        
        28.continue (继续) 跳过本次循环
            break (打破) 跳出整个循环

        29.数组
            1. 数组：存储多个数据的容器
            let score5 = [10, 100, 101, 99, 60];
            2. 创建数组
                2.1 通过关键字 Array，创建了一个空数组
                    let arr = new Array();
                2.2 通过字面量创建一个空数组
                    var arr1 = [];
                2.3 创建了一个数组，并填充了数据
                    let arr2 = ['张飞', 66, true]; // 
            /*
                总结：
                    1. arr 数组名
                    2. 数组里的数据通过，隔开
                    3. 不限制数据类型
                    4. [] 包裹数据
            */ 
            3. 元素：数组里的每一个数据，成为元素
            4. 索引号：元素在数组中的顺序，从 0 开始，逐一增加
            5. 获取元素：通过索引号获取，数组名[index]，可以看做变量名
                console.log(arr2[0]);
                console.log(arr2[1]);
                console.log(arr2[2]);
                // 变量只声明，不赋值
                console.log(arr2[3]); // undefined
            6.遍历数组，把数组中的元素，全都访问一遍
                var arr = [22,'貂蝉',true,'男'];
                for (let i = 0; i < 4; i++) {
                    console.log(arr[i]);
                }
        
            ###数组去重
                let arr = ['关羽', '张飞', '程咬金', '吕布', '张飞', '张飞', '张飞', '吕布'];
                let arr1 = [];
                for (let i = 0; i < arr.length; i++) {
                    let flag = false;
                    for (let j = 0; j < arr1.length; j++) {
                        if (arr1[j] == arr[i]) {
                            flag = true;
                            break;
                        }
                    }
                    if (!flag) {
                        arr1[arr1.length] = arr[i];
                    }
                }
                console.log(arr1);

            ###筛选数组
                let arr = [2, 6, 77, 52, 25, 7];
                let arr1 = [];
                let index = 0;

                for (let i = 0; i < arr.length; i++) {
                    if (arr[i] >= 10) {
                        // console.log(arr[i]);
                        // arr1[index] = arr[i];
                        // index++;
                        // arr1 的长度增长规律和 index 一致
                        arr1[arr1.length] = arr[i];
                    }
                }
                console.log(arr1);

            ###冒泡排序
                console.log(`----------------for 循环-----------------`);
                let arr1 = [11, 10, 8, 1, 3, 2, 23, 15];
                console.log(arr1);
                for (let j = 0; j < arr1.length - 1; j++) {
                    for (let i = 0; i < arr1.length - 1 - j; i++) {
                        // arr[i]  arr[i+1] 
                        if (arr1[i] > arr1[i + 1]) {
                            // 交换位置，大的放后面
                            let temp = arr1[i];
                            arr1[i] = arr1[i + 1];
                            arr1[i + 1] = temp;
                        }
                    }
                }
                console.log(arr1); 


        30.函数：
            1. 封装了一段可以重复执行的代码，对外暴露了一个函数名，隐藏了函数内部的细节
            2. 使用时，调函数名即可
            3. 函数不调用，不执行，调用一次，执行一次
            4. 先声明，再使用，和变量一样
            5. 某个人做了某件事情，某个事情就是函数
            6. 函数就是某个动作，函数名用动词，函数名命名规则为小驼峰
            7. 函数、方法、API、接口 同一个事物，不同的名字
            8. 执行顺序：先声明，从上往下执行代码，遇到函数名，执行函数内的代码

            语法结构
                function 函数名 () {
                    函数体;
                }
            调用 ：
                函数名();

        31.带参函数
            语法结构
                function 函数名(形参){
                    let 形参; // 系统省略
                    形参 = 实参; // 调用时运行，系统省略
                    函数体;
                }
                函数名(实参);

                形参 ：形式上的参数
                实参 ：实际参与运算的数据

                总结：
                    1. 形参就是只声明，未赋值的变量
                    2. 调用函数的时候，把实参赋值给形参
                    3. 形参和实参尽量保持一致，多的不参与函数执行，少的默认 undefined
                
            ### 函数实参和形参个数不匹配问题
                function getsum(num1,num2){
                    console.log(num1+num2);
                }
                如果实参个数多于形参个数，会取到形参的个数
                    getsum(1,2,3);
                如果实参个数小于形参个数，形参可以看做是不用声明的变量，
                num2是一个变量但是没有接收值，定义为undefined，最终结果NaN
                    getsum(1);

        32.函数的返回值格式
            function 函数名(){
                return 需要返回的结果;     
            }
            函数名();

            注意：
                1. return 终止函数，之后的代码不再执行
                2. return 只能返回一个值 返回的结果是最后一个值
                3. 函数没有 return ，返回 undefined
                4. 函数的返回值可以选择接收，或者不接收

        33.arguments
            当不确定有多少个参数传递时，可以用arguments 来获取。
                1. 系统内置对象。每个函数自带的，系统帮我们生成的一个关键字
                2. 它是一个伪数组，保存了传递的所有实参。
            注意：只有函数才有arguments对象
            function fn(){
                console.log(arguments);
                console.log(arguments.length);
                console.log(arguments[2]);
                // 可以按照数组的方式遍历 arguments
                for (var i = 0; i < arrguments.length; i++){
                    console.log(arguments[i]);
                }
            }
            fn(1,2,3);
            fn(1,2,3,4,5);
            // 伪数组 并不是真正意义上的数组
            // 1. 具有数组的 length 属性
            // 2. 按照索引的方式进行存储的
            // 3. 它没有真正数组的一些方法 pop() push() 等

        34.函数的声明方式
            1. 通过关键字 function 函数的声明(命名函数)
                function skill() {
                    console.log("剑圣释放了无敌斩");
                }
                skill();
            2. 匿名函数(函数表达式)
                1. 给变量进行赋值，它的值是一个函数。
                2. 这个函数没有名字，可以通过变量名() 调用。
                3. 匿名函数，也可以传递参数。
                var method = function (hero) {
                    console.log(hero + '释放了东风破袭');
                }
                method("诸葛亮");
            3. 箭头函数(也属于匿名函数)
                let run = () => {
                    console.log('就这么跑来跑去');
                }
                run();

        35.作用域
            作用域 ：产生作用的区域
                作用 ：变量命名冲突
            1. js作用域：代码在某个范围内起作用和效果 目的是为了提高程序的可靠性，更重要的是减少代码冲突
            2. js的作用域(es6 之前) ：全局作用域  局部作用域
                全局作用域：整个script标签 或者是一个单独的js文件
                    var num = 10;
                局部作用域（函数作用域）在函数内部就是局部作用域 这个代码的名字只在函数内部起效果

            ###js 现阶段没有块级作用域
            在 es6 的时候新增块级作用域
                块级作用域 {}  if{} for{}
                // java  外面的是不能调用num的
                // if(xx) {
                //     int num = 10;
                // }
                console.log(num);
        
            ### 变量的作用域：
                全局变量：在全局作用域下，声明的变量
                局部变量：在函数内部声明的变量，在函数内部可用
            局部作用域可以使用全局变量，函数外部不能使用函数内部声明的变量
            形参是局部变量
            函数内部未声明直接赋值的变量，是全局变量，不推荐

        36.全局变量和局部变量
            1. 全局变量：在全局作用域下的变量 在全局下都可以使用
                // 注意：在函数内部没有声明直接赋值的变量也是全局变量,不推荐使用
            2. 局部变量：在局部作用域下的变量 只能在局部(函数内)使用
                // 注意：函数的形参也可以看作为局部变量
            3. 从执行效率来看全局变量和局部变量
                (1) 全局变量只有在浏览器关闭的时候才会销毁，比较占内存资源
                (2) 局部变量  当我们程序执行完毕就会销毁，比较节约内存资源
        
        37.作用域链
            内部函数访问外部函数的变量，采取的是链式查找的方式决定取哪个值 这种结构我们称作为作用域链（就近原则）
            var num = 10;
            function fn(){  // 外部函数
                var num = 20;
                function fun(){  // 内部函数
                    console.log(num);
                    // 链式查找 num 值 == 20
                }
                fun();
            }
            fn();

        38.预解析
            // 1. 直接输出报错
                console.log(num);
            // 2. 先输出，后声明
                console.log(num);
                var num = 10; // undefined  变量提升相当于 var num;
            // 3. 正常输出
                fn();
                function fn(){
                    console.log(11);
                } // 函数提升 正常输出
            // 4. 匿名函数报错
                fun();
                var fun = function(){
                    console.log(22);
                } // 变量提升相当于 var fun;

            js 代码是由浏览器中的js解析器来执行的。
            1. js 引擎(解析器)在运行js 代码的时候分为两步 ：预解析和代码执行
                (1) 预解析：js 引擎会把 js里面所有的 var 还有 function 提升到当前作用域的最前面
                (2) 代码执行 按照代码书写的顺序从上往下执行
            2. 预解析分为 变量预解析（变量提升）和 函数预解析（函数提升）
                (1) 变量提升 就是把所有的 var 变量声明提升到当前的作用域最前面 不提升赋值操作
                (2) 函数提升 就是把所有的 function 函数声明提升到当前作用域的最前面  不调用函数

            ### 案例
                f1();
                console.log(c);
                console.log(b);
                console.log(a);

                function f1() {
                    var a = b = c = 9;
                    // 相当于 var a = 9; b = 9; c = 9;没有声明，相当于全局变量
                    console.log(a);
                    console.log(b);
                    console.log(c);
                }
                //相当于以下代码
                function f1() {
                    var a;
                    a = 9;
                    b = 9;
                    c = 9;
                    console.log(a); // 9
                    console.log(b); // 9
                    console.log(c); // 9
                }
                f1();
                console.log(c); // 9
                console.log(b); // 9
                console.log(a); // 无定义，报错

        39. 对象：
            1. 对象是属性的无序集合
            2. 对象是一个具体的事物，存储数据的一种格式
            3. 对象的成员有属性和方法
            4. 对象用 {} 来声明
            5. 对象是复杂数据类型 object
            6. 相对于数组，结构更加清晰
            7. 之前的变量和方法可以看做 window 的一个属性。window 一般省略
            8. 使用场景：作为函数的参数，一次传递多个属性
            9. 对象可以动态的添加属性
            10. 获取对象的属性
                对象名.属性名
                对象名['属性名']
            11. 对象方法的调用
                对象名.方法名();
            12. 函数就是某个人做了某件事，某个人就是对象，某件事情就是函数

            语法总结：
                1. 创建对象，字面量{} 
                2. 属性和方法都是键值对 key value
                3. 逗号分割
                4. 方法是一个匿名函数

        40. 类和对象
            C语言：直接对位进行操作，控制管脚的通电、断点。因此可以操作硬件。程序员需要对内存进行管理。
            面向对象的语言：JS Java Python。自动管理内存。
            驱动：管理操作硬件的函数。
            C语言最大的特点：直接，快。

            语言的发展趋势:高性能、高可用、高并发。语言简单。

            Linux:一切皆文件。

            重点：
                什么是对象：一个具体的事物。
                类：一个抽象的概念。
                对象：一个具体的事物。
                通过类，生成一个对象的过程成为实例化，因此，对象也成为实例。
                类有两个成员：属性(变量)和方法(函数)。
                类：对事物的公共特征(属性和方法)进行抽取。
                对象：属性的无序集合。

            C语言: 面向过程。
            js、Python、Java:面向对象。一切皆对象。将生活中事物，映射为对象。
            面向对象的特性(面试题):
                1. 封装:函数
                2. 继承:
                3. 多态:自己总结。

        41.构造函数
            给对象添加属性和方法并返回这个对象
            语法结构：
                function 构造函数名(属性值1, 属性值2){
                    this.属性名1 = 属性值1;
                    this.属性名2 = 属性值2;
                    this.方法名1 = function () {
                        函数体;
                    };
                    this.方法名2 = () => {
                        函数体;
                    }
                }

            函数(构造函数)，封装一段可以重复执行的代码(给对象动态的添加属性和方法，给对象进行初始化)
            通过返回值，把初始化的对象给返回
            把对象的属性值作为函数的参数

            构造函数：
                1. 作用：创建对象
                2. 返回值是一个对象，默认省略
                3. 封装的代码是，给对象动态的添加属性和方法
                4. this 是当前对象
                5. 函数名用大驼峰
                6. 配合关键字 new 使用
                7. 构造函数和类是一码事
                8. 就是对象公共属性和方法的抽取
                9. 属性名和形参尽量保持一致，可读性强

            约定大于规范，规范大于编码

        42.构造函数和对象
            1. 构造函数(类)，泛指某个事物的一大类
                function Hero(name, sex, level) {
                    this.name = name;
                    this.sex = sex;
                    this.level = level;
                    this.skill = () => {
                        console.log(`释放技能`);
                    }
                }
            2. 对象，一个具体的事物
                let libai = new Hero('李白', '男', 18);
            3. 利用类(构造函数)创建对象的过程成为实例化，对象也叫实例
            4. Object Array,是系统自带的构造函数
                let obj = new Object();
                let arr = new Array();
            5. Object 是所有类的根类
            6. 函数都是 function 关键字的一个实例

        43.new 关键字执行过程
            1. 后面跟着函数名()，调用了构造函数
            2. 创建了一个空对象
            3. 给当前对象，动态添加属性和方法
            4. 返回这个对象

        44.for in 遍历对象的属性
            for (let key in 对象名) {
                console.log(key, 对象名[key]);
            }

        44.学习新对象思想
            1. 内置对象:系统自带的对象, arguments,Arrary,Object
            2. MDN:
            3. 学习方法：
                 3.1 这个对象是干什么的
                 3.2 输入:参数的个数及数据类型
                 3.3 处理:方法的作用
                 3.4 输出:方法的结果

        45.数学对象 Math
            // 绝对值
            console.log(Math.abs('-1'));
            console.log(Math.abs(-2));

            // 向上取整
            console.log(Math.ceil(0.95));  // 1
            console.log(Math.ceil(1.95));  // 2
            console.log(Math.ceil(-1.95)); // -1

            // 向下取整
            console.log(Math.floor(3.2));  // 3 

            // parseInt 向下取整
            console.log(parseInt(2.1));  // 2

            // 四舍五入
            console.log(Math.round(3.3));  // 3
            console.log(Math.round(3.5));  // 4

            ###得到一个两数之间的随机整数
            function getRandomInt(min, max) {
                min = Math.ceil(min);
                max = Math.floor(max);
                return Math.floor(Math.random() * (max - min)) + min; //不含最大值，含最小值
            }
            for (let i = 0; i < 10; i++) {
                console.log(getRandomInt(1, 11));
            }

        46.日期对象 Date
            Date 对象是基于1970年1月1日(世界标准时间)起的毫秒数
            Date() 日期对象 是一个构造函数 必须使用new 来调用
            1. 无参，当前的系统时间
                let d1 = new Date();
                console.log(d1);

            2. 参数是指定格式时间的字符串(某个时间点的对象)
                let d2 = new Date('2022-02-22 16:50:00');
                d2 = new Date(2022,2-1,22); // 月份需要减1
                console.log(d2);

            // 格式化 年、月、日、星期
            let year = d2.getFullYear();
            let month = d2.getMonth() + 1; // getMonth() 返回月份0-11
            let date = d2.getDate();
            let day = d2.getDay(); // 周日0 到周六6
            var week = ['周日', '周一', '周二', '周三', '周四', '周五', '周六'];
            console.log("今天是" + year + '年' + month + '月' + date + '日' + week[day]);

            // 格式化 时、分、秒
            function getNow() {
                var date1 = new Date();
                var h = date1.getHours();
                var m = date1.getMinutes();
                var s = date1.getSeconds();

                h = h < 10 ? '0' + h : h;
                m = m < 10 ? '0' + m : m;
                s = s < 10 ? '0' + s : s;

                return h + ':' + m + ':' + s;
            }
            console.log(getNow());

            ### 获取总的毫秒数(时间戳)
                1. 通过 valueOf() getTime()
                    let date = new Date();
                    console.log(date.getTime());
                    console.log(date.valueOf());
                2. 简单的写法(最常用的写法)
                    console.log(+new Date());
                3. H5 新增的 获得总的毫秒数
                    console.log(Date.now());

            // 某个时间到当前的倒数计时
            function countDown(date) {
                let date1 = +new Date();
                let date2 = date.valueOf();

                let sub = (date2 - date1) / 1000; // 1 s = 1000 ms

                d = parseInt(sub / 60 / 60 / 24);  //  计算天数
                h = parseInt(sub / 60 / 60 % 24)   //   计算小时
                m = parseInt(sub / 60 % 60);       //   计算分数
                s = parseInt(sub % 60);            //   计算当前秒数

                h = h < 10 ? '0' + h : h;
                m = m < 10 ? '0' + m : m;
                s = s < 10 ? '0' + s : s;

                return `${h}:${m}:${s}`;
            }
            console.log(countDown(new Date('2022-02-23 11:50:00')));

        47.数组对象 Array
            1. 检测是否为数组(传递的不是数组时返回 [])
                (1) instanceof 运算符 (arr instanceof Array)
                    console.log(arr instanceof Array);
                    
                    // 判断当前对象是否为某个实例
                    console.log(arr instanceof Date);
                    let date = new Date();
                    console.log(date instanceof Date);
                (2) Array.isArray(arr) (H5 新增，IE9 以上支持)
                    console.log(Array.isArray(arr));
                    console.log(Array.isArray(date));

            2. 添加删除数组元素
                (1) push() 在数组末尾添加一个或多个数组元素 push 推
                    var arr = [1, 2, 3];
                    console.log(arr.push(4, 'x')); // 5 返回值为新数组的长度
                (2) unshift 在数组开头添加一个或多个数组元素
                    var arr = [1, 2, 3];
                    console.log(arr.unshift(-1, 0)); // 5 返回值为新数组的长度
                (3) pop() 删除数组的最后一个元素 没有参数
                    var arr = [1, 2, 'aa'];
                    console.log(arr.pop()); // aa 返回的是删除的那个元素
                (4) shift() 删除数组的第一个元素 没有参数
                    var arr = [1, 2, 'aa'];
                    console.log(arr.shift()); // 1 返回的是删除的那个元素

            ### 筛选数组
                var arr = [1500, 1200, 2000, 2100, 1800];
                var newArr = [];
                for (var i = 0; i < arr.length; i++) {
                    if (arr[i] <= 2000) {
                        newArr.push(arr[i]);
                    }
                }

                console.log(newArr);

            3. 数组排序
                (1) 翻转数组 reverse()
                    var arr = [1, 2, 3];
                    arr.reverse();
                (2) 数组排序（原地算法）
                    var arr = [3, 18, 2];
                    arr.sort(); // 18, 2, 3

            ### 数字排序
                array1.sort(function (a, b) {
                    return a - b;
                });
                console.log(array1);

            4. 获取数组元素索引
                (1) indexOf() 
                    只返回第一个满足条件的索引号
                    如果找不到，返回 -1
                    var arr = [1, 2, 3, 2];
                    console.log(arr.indexOf(2)); // 1
                (2) lastIndexOf()
                    返回最后一个满足条件的索引号
                    如果找不到，返回 -1
                    var arr = [1, 2, 3, 2];
                    console.log(arr.lastIndexOf(2)); // 3

            ### 数组去重
                function unique(arr) {
                    var newArr = [];
                    for (let i = 0; i < arr.length; i++) {
                        if(newArr.indexOf(arr[i]) === -1){
                            newArr.push(arr[i]);
                        }
                    }
                    return newArr;
                }
                let demo = unique(['blue', 'green', 'blue','a','c','a']);
                console.log(demo);

            5. 数组转换为字符串
                (1) toString() 
                    var arr = [1, 2, 3];
                    console.log(arr.toString());
                (2) join(分隔符)
                    var arr = [1, 2, 3];
                    console.log(arr.join('-')); // 1-2-3

            6. 合并数组返回新数组
                concat() 方法用于合并两个或多个数组。
                    const array1 = ['a', 'b', 'c'];
                    const array2 = ['d', 'e', 'f'];
                    const array3 = ['g', 'h', 'i'];
                    const array4 = array1.concat(array2, array3);           
                    console.log(array3);
                
            7. 数组截取
                slice() 方法返回一个新的数组对象，原始数组不会被改变
                这一对象是一个由 begin (从 0 计)和 end (从 -1 计)决定的原数组的浅拷贝（包括 begin，不包括end）
                    const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];
                    console.log(animals.slice(2)); // Array ["camel", "duck", "elephant"]
                    console.log(animals.slice(2, 4)); // Array ["camel", "duck"]
                    console.log(animals.slice(-2)); // Array ["duck", "elephant"]
                    console.log(animals.slice()); // Array ["ant", "bison", "camel", "duck", "elephant"]
                
            8. 数组删除
                splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。
                splice(index, num, ele) 从索引 index 的位置开始删除 num 个元素，添加元素 ele
                    const months = ['Jan', 'March', 'April', 'June'];
                    months.splice(1, 0, 'Feb');
                    console.log(months); // Array ["Jan", "Feb", "March", "April", "June"]

            9. 数组遍历
                // forEach 遍历数组
                forEach() 方法对数组的每个元素执行一次提供的函数。
                arr.forEach(function (value, index, array) {
                    console.log(value, index, array);
                });

        48.基本包装类：
            把基本数据类型包装成(转化为)复杂数据类型
            然后，就可以使用对应的属性和方法了
            比如，Array 的翻转、排序、切割等等
                let str = 'abcd';
                console.log(str.length);

                // 1. 把简单数据类型包装为复杂数据类型
                let str = new String('abcd');
                // 2. 把临时变量的值给 str
                str = temp;
                // 3. 销毁这个临时变量
                temp = null;

            ### JS 提供了 三个 特殊的引用类型：Boolean、Number、String。
                https://www.cnblogs.com/xiaoxiaogogo/p/3627708.html

        49.字符串对象 String
            1. 字符串的不可变性
                1. 字符串的不可变性：当对字符串进行切割，拼接，翻转的时候，原字符串是不会改变,返回新的字符串。
                2. 操作进行不要出现大量的字符串拼接，产生很多的内存碎片。
                3. 变量名 = null  内存地址的清空。
                    let str = '';
                    for (var i = 0; i < 1000; i++) {
                        str = str + i;
                    }
                    console.log(str); // 产生大量内存碎片，反应迟钝

            2. 根据字符返回地址
                字符串对象: 根据字符返回第一次出现位置，不存在返回-1  类比 数组的 indexOf
                语法结构: str.indexOf('要查找的字符', [起始的位置])
                    let str = '黑色毛衣黑色幽默';
                    console.log(str.indexOf('黑', 1));

                ### 案例 查找字符串 "黑色幽默黑色毛衣黑旋风李逵" 中所有 "黑" 出现的位置以及次数
                    let str = "黑色幽默黑色毛衣黑旋风李逵";
                    let index = str.indexOf('黑');
                    let arr = [];
                    while (index != -1) {
                        arr.push(index);
                        console.log(index);
                        index = str.indexOf('黑', index + 1);
                    }
                    console.log(arr, arr.length);
                
            3. 根据位置返回字符
                (1) charAt(index) 根据索引号返回字符
                (2) charCodeAt(index)  返回相应索引号的字符ASCII值 目的： 判断用户按下了哪个键
                (3) str[index] H5 新增的
                    var str = "abcdef";
                    console.log(str.charAt(1)); // b
                    console.log(str.charCodeAt(1)); // 98
                    console.log(str[2]); // c

                ### 案例 判断一个字符串 'abcoefoxyozzopp' 中出现次数最多的字符，并统计其次数。
                    let result = 'abcoefoxyozzopp';
                    let info = {};
                    for (let i = 0; i < result.length; i++) {
                        // 当前字符
                        let char = result[i];
                        // 对象的属性是否存在
                        if (info[char]) {
                            // 存在则自加1
                            info[char]++;
                        } else {
                            // 不存在则，赋值为1
                            info[char] = 1;
                        }
                    }
                    // 遍历对象的属性和值
                    let max = info[result[0]];
                    let ch = '';
                    for (let k in info) {
                        if (info[k] > max) {
                            max = info[k];
                            ch = k;
                        }
                    }
                    console.log(ch, max); // o 4

            4. 字符串操作方法
                1. concat('字符串1','字符串1'...)
                    let str = 'andy';
                    console.log(str.concat('red')); // andyred
                2. substr('截取的起始位置', '截取几个字符');
                    var str1 = '雨下整夜我的爱溢出就像雨水';
                    console.log(str1.substr(2, 2)); // 整夜
                3. replace('被替换的字符','替换为的字符')  只替换第一个字符
                    var str2 = 'andyandy';
                    console.log(str2.replace('a','b')); // bndyandy

                ### 把字符串 'absjdaajijasa' 中的 a 替换为 *
                let str = 'absjdaajijasa';
                while (str.indexOf('a') != -1) {
                    str = str.replace('a', '*');
                }
                console.log(str); // *bsjd**jij*s*

                4. split('分隔符') 字符串转换为数组
                    let str = 'abs,jdaa,jij,asa';
                    console.log(str.split(',')); // (4) ['abs', 'jdaa', 'jij', 'asa']

                5. startsWith('开头的字符串', 起始位置)
                   endsWith('结尾的字符串', 判断的字符串的末尾位置)
                    let str1 = 'Cats are the best!';
                    console.log(str1.startsWith('best', 13)); // true
                    console.log(str1.endsWith('best', 17)); // true

                6. slice() 方法提取某个字符串的一部分，并返回一个新的字符串，且不会改动原字符串。
                这一对象是一个由 begin (从 0 计)和 end (从 -1 计)决定的原数组的浅拷贝（包括 begin，不包括end）

                7. substring 提取从 indexStart 到 indexEnd（不包括）之间的字符。
                    var anyString = "Mozilla";
                    // 输出 "Moz"
                    console.log(anyString.substring(0,3));
                    console.log(anyString.substring(3,0));
                    console.log(anyString.substring(3,-3));
                    console.log(anyString.substring(3,NaN));
                    // 输出 "Mozilla"
                    console.log(anyString.substring(0,7));
                    console.log(anyString.substring(0,10));

        50.简单类型与复杂类型
            简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型
            1. 值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型
                string, number, boolean, undefined, null
                注：null返回的是一个空的对象。如果有个变量打算存储为对象，暂时没想好，赋值为 null
            2. 引用类型：复杂数据类型，在存储时变量中存储的仅仅是地址(引用)，因此叫做引用数据类型
                通过 new 关键字创建的对象(系统对象、自定义对象)，如 Object、Array、Date等
            
            在内存里，抽象化：简单数据类型存放在 栈 里，复杂数据类型存放在 堆 里

        51.API 和 Web API
            API：Application Programming Interface  应用程序编程接口
                预先定义的函数 只要使用，不用纠结内部如何实现
            Web API：浏览器提供的一套操作浏览器功能和页面元素的API（BOM 和 DOM）
 
        52.DOM
            Document Object Model  文档对象模型（把所有的看做对象）
            W3C 组织推荐的 处理可扩展标记语言(html、xml) 的标准编程接口
            动态改变网页的结构、内容和样式

            文档：一个页面就是一个文档，DOM 中使用 document 表示
            元素：页面中的所有标签都是元素，DOM 中使用 element 表示
            节点：网页中的所有内容都是节点（标签、属性、文本、注释等），DOM 中使用 node 表示

        53.获取页面元素
            1. 根据 ID 获取
                使用 getElementById 返回一个元素对象
                注意：文档页面从上往下加载，所以先有标签，script 写在标签的下面
                
                console.log(document.getElementId('div')); // <div></div>
                console.dir(document.getElementId('div')); // 打印元素对象
            2. 根据标签名获取
                (1) 使用 getElementsByTagName 返回多个元素对象(获取过来的元素对象的集合)
                (2) 以 伪数组 形式存储
                (3) 通过遍历获取每个元素对象
                    let result = document.getElementsByTagName('li');
                    for (let i = 0; i < lis.length; i++) {
                        console.log(lis[i]);
                    }
                    注：如果页面没有该元素，返回空的伪数组  HTMLCollection []
                (4) 通过 指定父级 获取元素内部指定标签名的子元素
                    let ol = document.getElementById('ol');
                    let lis = ol.getElementsByTagName('li');
                    console.log(lis);
                    注意：父元素必须指明 console.log(document.getElementById('ol').getElementsByTagName('li'));

            3. H5 新增获取元素方式 (ie9 以上支持)
                (1) getElementsByClassName 根据类名获取某些元素集合
                (2) querySelector 返回指定选择器的第一个元素对象
                    选择器需要加符号 .box #nav
                    console.log(document.querySelector('.box'));
                (3) querySelectorAll 返回指定选择器的所有元素集合

            4. 获取特殊元素
                (1) 获取body 元素
                var bodyEle = document.body;
                console.log(bodyEle);

                (2) 获取html 元素
                var htmlEle = document.documentElement;
                console.log(htmlEle);
                
        54.事件基础
            1. 事件: 触发响应的一种机制(特定情况触发的函数)。比如：鼠标左键、右键、经过、离开、左击、右击、键盘按下...
            2. 事件的三要素: 
                2.1 事件源: 事件被触发的对象(某个人)
                2.2 事件类型: 如何触发 什么事件(鼠标左键、右键、经过、离开)
                2.3 事件处理程序: 通过一个函数名赋值的方式完成(具体业务逻辑)
            3. 手动调用函数 jay.onclick();
            4. 执行事件步骤
                4.1 获取事件源(获取元素)
                4.2 绑定事件(绑定函数：属性进行重新赋值)
                4.3 添加事件处理程序(编写函数: 把具体的业务逻辑封装到函数体)
            5. 操作元素
                5.1 改变元素内容
                    (1) element.innerText 只识别文本 去除空格和换行
                    (2) element.innerHTML 对 H5 的代码进行渲染
                5.2 改变元素属性
                    ele.属性 = value  如 src, title, id, name, href
                5.3 改变表单属性
                    (1) 表单中的文字内容通过 value 来修改
                        inpt.value='被点击';
                    (2) 按钮禁用 disabled
                        btn.disabled = true;
                    (3) this 是 函数的调用者
                        this.disabled = true;

                ### 仿京东显示密码按钮
                    var flag = true;  // 标识符 密码类型为true
                    eye.onclick = function () {
                        flag = !flag;
                        if (flag) {
                            eye.src = 'images/close.png';
                            input.type = 'password';
                        } else {
                            eye.src = 'images/open.png';
                            input.type = 'text';
                        }
                    }
                5.4 改变样式属性
                    (1) ele.style  行内样式操作 权重较高
                    注意：样式采用驼峰命名法，如 fontSize、backgroundColor
                    (2) ele.className  类名样式操作
                        this.className = 'change'; 覆盖原有属性
                        (多类名选择器防止覆盖)

                ### 仿新浪注册页面
                    ipt.onblur = function () {
                        // input.value.length 获取表单元素长度
                        if (this.value.length < 6 || this.value.length > 16) {
                            p.className = 'message right';
                            p.innerHTML = '密码合法';
                        } else {
                            p.className = 'message wrong';
                            p.innerHTML = '密码不合法';
                        }
                    };
                
                5.5 排他思想(算法)
                    let btns = document.querySelectorAll('button');
                    // let btns = document.getElementsByTagName('button');
                    console.log(btns); // 伪数组
                    for (let i = 0; i < btns.length; i++) {
                        // 给每个按钮绑定点击事件
                        btns[i].onclick = function () {
                            // 先清空所有按钮的背景
                            for (let j = 0; j < btns.length; j++) {
                                btns[j].style.backgroundColor = '';
                            }
                            // 留下我自己 
                            this.style.backgroundColor = 'skyblue';
                        }
                    }

                ### 切换图片
                    imgs[i].onclick = function() {
                        document.body.style.backgroundImage = 'url(' + this.src + ')';
                    }
                
                ### 表格隔行变色
                    var trs = document.querySelector('tbody').querySelectorAll('tr');
                    for (var i = 0; i < trs.length; i++) {
                        trs[i].onmouseenter = function () {
                            this.className = 'bg';
                        }
                        trs[i].onmouseleave = function () {
                            this.className = '';
                        }
                    }

                ### 表单全选取消全选
                    let j_cbAll = document.querySelector('#j_cbAll');
                    let inputs = document.querySelector('#j_tb').querySelectorAll('input');
                    // 1. 复选框，跟随全选状态变化。
                    j_cbAll.onclick = function () {
                        for (let i = 0; i < inputs.length; i++) {
                            inputs[i].checked = this.checked;
                        }
                    }            
                    // 2. 复选框点击的时候，如果有一个没有被选中，则全选为 false
                    for (let i = 0; i < inputs.length; i++) {
                        inputs[i].onclick = function () {
                            // 标志位
                            let flag = true;
                            for (let j = 0; j < inputs.length; j++) {
                                // 复选框的选中状态
                                let status = inputs[j].checked;
                                if (!status) {
                                    flag = false;
                                    break;// 跳出循环
                                }
                            }
                            // 给全选赋值
                            j_cbAll.checked = flag;
                        }
                    }

                5.6 自定义属性
                    (1) 获取元素的属性值
                        ele.属性  获取内置属性值
                        ele.getAttribute('属性')  可以获得自定义属性
                    (2) 设置元素属性值
                        <1> ele.属性 = '值'
                        <2> ele.setAttribute('属性', '值');  主要针对自定义属性
                            ele.setAttribute('class', 'footer');
                    (3) 移除属性
                        ele.removeAttribute('属性');

                ### tab 栏切换
                    let lis = document.querySelectorAll('li');
                    let divs = document.querySelector('.tab_con').querySelectorAll('div');
                    // console.log(divs);

                    for (let i = 0; i < lis.length; i++) {
                        // 添加索引号
                        lis[i].setAttribute('index', i);
                    
                        lis[i].onclick = function () {
                            // 先全部清空样式
                            for (let j = 0; j < lis.length; j++) {
                                lis[j].className = '';
                            }
                        
                            // 当前 li 样式改变
                            this.className = 'current';
                        
                            // 清空所有的样式
                            for (let j = 0; j < divs.length; j++) {
                                divs[j].style.display = 'none';
                            }
                            // 当前样式改变
                            let index = this.getAttribute('index');
                            divs[index].style.display = 'block';
                        }
                    }

                5.7 h5自定义属性
                    1. 返回值是一个对象。属性是 data- 作为前缀
                    2. 约定大于规范，规范大于编码。属性都是 data- 作为前缀
                    3. 属性名 data- 默认省略，小驼峰
                    <div data-index="data-index"></div>
                    console.log(div.getAttribute('data-index'));
                    console.log(div.dataset.index);
                    console.log(div.dataset['index']);

            6. 节点操作
                6.1 节点概述
                    节点类型：元素(标签)节点(1)，属性节点(2)，文本节点(3)。一般我们都是操作元素节点。
                    节点是对象:有名字、类型、节点值
                    元素节点的值null
                    文本节点的值是文本。
                    console.log(ul.childNodes[0].nodeName);
                    console.log(ul.childNodes[0].nodeType);
                    console.log(ul.childNodes[0].nodeValue);
                6.2 节点层级
                    (1) 父节点 parentNode
                        ele.parentNode  返回离元素最近的父节点
                    (2) 子节点 
                        ele.childNodes  得到所有子节点(包括元素、文本节点)
                        ele.children  获取索引子元素节点（非标准，常用）
                        ele.firstChild  获取第一个子节点
                        ele.lastChild  获取最后一个子节点
                        ele.firstElementChild 获取第一个子元素节点(ie9)
                        ele.lastElementChild 获取最后一个子元素节点(ie9)

                    ### 下拉菜单
                        let nav = document.querySelector('.nav');
                        let lis = nav.children;                           
                        for (var i = 0; i < lis.length; i++) {
                            // 鼠标进入
                            lis[i].onmouseenter = function () {
                                this.lastElementChild.style.display = 'block';
                            }
                            // 鼠标离开
                            lis[i].onmouseleave = function () {
                                this.lastElementChild.style.display = 'none';
                            }
                        }

                    (3) 兄弟节点
                        node.nextSibling  下一个兄弟节点(包括元素、文本节点等等)
                        node.previousSibling  上一个兄弟节点(包括元素、文本节点等等)
                        node.nextElementSibling  下一个兄弟元素节点
                        node.previousElementSibling  上一个兄弟元素节点

                6.3 创建节点
                    创建元素  document.createElement
                        var li = document.createElement('li');
                        li.innerHTML = '孙红雷';
                6.4 添加节点
                    (1) 元素后面追加节点  node.appendChild
                        ul.appendChild(li);

                        ### appendchild 和 append 区别
                            https://www.cnblogs.com/jellyz/p/13925489.html
                            （1）ParentNode.append()允许追加 DOMString 对象，而 Node.appendChild() 只接受 Node 对象。
                            （2）ParentNode.append() 没有返回值，而 Node.appendChild() 返回追加的 Node 对象。
                            （3）ParentNode.append() 可以追加多个节点和字符串，而 Node.appendChild() 只能追加一个节点。
                    (2) 指定元素前面添加  node.insertBefore(child, 指定元素);
                        ul.insertBefore(li1, ul.children[0]);

                6.5 删除节点
                    node.removeChild(child);
                    ul.removeChild(ul.children[0]);

                ### 删除留言
                    let textarea = document.querySelector('textarea')
                    let btn = document.querySelector('button');
                    let ul = document.querySelector('ul');
                                
                    btn.onclick = function () {
                        // 获取表单内容
                        let value = document.querySelector('textarea').value;
                        if (value == '') {
                            alert('不能为空');
                            return;
                        }
                    
                        // 创建节点
                        let li = document.createElement('li');
                        // 填充元素内容
                        li.innerHTML = `${value}<a href="javascript:;">删除</a>`;
                        // 追加节点
                        ul.insertBefore(li, ul.children[0]);
                        textarea.value = '';
                    
                        let as = document.querySelectorAll('a');
                        for (let i = 0; i < as.length; i++) {
                            as[i].onclick = function () {
                                // 删除节点
                                ul.removeChild(this.parentNode);
                            }
                        }
                    }

                6.6 复制节点(克隆节点)
                    node.cloneNode();
                    1. 浅拷贝  只复制标签不复制里面的内容
                        let li1 = ul.children[0].cloneNode();
                        let li1 = ul.children[0].cloneNode(false);
                    2. 深拷贝  复制标签及其内容
                        let li1 = ul.children[0].cloneNode(true);

                6.7  三种动态创建元素区别
                    (1) document.write()
                        如果页面文档流加载完毕，再调用这句话会导致页面重绘
                    (2) element.innerHTML
                        如果数组转化为字符串，则效率较高，但结构稍复杂。
                    (3) document.createElement()
                        插入大量元素效率较低，但结构清晰。

        55. 事件高级
            1. 注册事件(绑定事件)
                传统方式(唯一性)和方法监听注册方式
                addEventListener(type, fn(), true/false);
                attachEvent('onclick',fn()); (ie9以前版本支持)

                ### 注册事件兼容性解决方案(封装函数)
                function addEventListener(element, eventName, fn){
                    // 判断当前浏览器是否支持 addEventListener
                    if (element.addEventListener) {
                        element.addEventListener(eventName,fn); // 第三个参数默认为 false
                    } else if (element.attachEvent) {
                        element.attachEvent('on'+eventName, fn);
                    } else {
                        // 相当于 element.onclick = fn;
                        element['on' + eventName] = fn;
                    }
                }
            2. 删除事件(解绑事件)
                (1) 传统方式删除事件
                    divs[0].onclick = function () {
                        divs[0].onclick = null;  // 内存地址清空，自动的垃圾回收。
                    }
                (2) removeEventListener 删除事件
                    divs[1].addEventListener('click', fn); // fn 不需要加小括号
                    function fn() {
                        console.log(this);
                        divs[1].removeEventListener('click', fn);
                    }
                (3) detachEvent  ie 8 以下
                    divs[2].attachEvent('onclick', fn1);
                    function fn1() {
                        alert(33);
                        divs[2].detachEvent('onclick', fn1);
                    }

            3. DOM 事件流
                事件传播的过程(捕获阶段 -> 当前目标阶段 -> 冒泡阶段)
                // 捕获： document ——> html ——> body ——> father  ——> son
                // 冒泡： son  ——> father ——> body  ——> html  ——> document 
                (1) 事件流描述页面中接收事件的顺序。
                (2) DOM 事件流：事件发生时会在元素节点之间按照特定的顺序触发。
                (3) 事件只能在冒泡或捕获阶段触发，只能在其中的一个阶段触发。
                    true 捕获阶段，默认是 false 冒泡阶段
            4. 事件对象
                (1) e 就是事件对象，也可以写成 event，作为函数的形参。
                (2) 事件对象有了事件才会存在，是系统自动创建的，不需要我们传递参数
                (3) 事件对象是事件的一系列相关数据的集合。里面可以查看很多属性，比如坐标
                (4) ie 678 有兼容性问题。通过 window.event 获取事件对象（解决：e = e || window.event）
            5. 常见事件对象的属性和方法
                (1) target 和 this 区别
                    <1> e.target 返回的是触发事件的对象（元素）
                    <2> this 返回的是绑定事件的对象（元素） 
                    e.srcElement（ie6、7、8兼容性问题）（解决：e = e || e.srcElement）
                    currentTarget（ie6、7、8不认识）与 this 属性相似
                (2) 返回事件类型   e.type   不带 on
                (3) 阻止默认行为(事件) e.preventDefault();
                    让链接不跳转 或者提交按钮不提交 

                    ### 传统的注册方式：
                        a.onclick = function(e){}
                        1. 普通浏览器 
                            e.preventDefault(); 方法 // dom 标准写法
                        2. 低版本浏览器
                            e.returnValue; 属性 // ie678
                        3. return false; 无兼容性问题
                            注意：return 后面的代码不执行，只限于传统注册方式
                (4) 阻止事件冒泡
                    标准写法：e.stopPropagation // 停止传播
                    低版本兼容性：e.cancelBubble  // 取消冒泡

            6. 事件委托(事件代理，jQuery叫事件委派)
                事件委托的原理：
                    事件监听器设置在父节点上，然后利用冒泡原理影响设置每个子节点
                    用 e.target 获取子节点
                    通过冒泡，li 把事件都委托给 ul。
                    优点：可以提高性能，节约计算机资源。
            7. 常用的鼠标事件
                7.1 常用鼠标事件
                    (1) contextmenu 右键菜单
                        可以通过 e.preventDefault(); 禁用
                    (2) selectstart 禁止鼠标选中(开始选中)
                    (3) mousemove  鼠标每移动1px触发
                7.2 鼠标事件对象
                    clientX/clientY: 鼠标在可视区的x和y坐标(距离左边和上边距离)
                    pageX/pageY:   鼠标在文档的x和y坐标(加上被卷去的头部)
                    screenX/screenY: 鼠标到电脑屏幕的距离。
            8. 常用的键盘事件
                1. keyup：键盘弹起触发
                2. keydown：键盘按下，一直触发
                3. keypress：键盘按下，一直触发，但不能触发功能键(ctr、shift等)

        56. BOM
            1. BOM 概述
                BOM：浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。
                BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差。
                browser BOM ： 刷新浏览器、前进、后退、更改尺寸，返回顶部
                BOM 的对象是 window。
                    1. 全局对象，就是整个浏览器。
                    2. 提供一些接口，提供了很多操作浏览器的方法。
                window 默认省略
                    声明的变量和函数都是 window 的属性和方法

            2. window 对象的常见事件
                2.1 窗口加载事件
                    (1) window.onload = function (){}
                        或者
                        window.addEventListener('load',function(){});
                        当文档内容完全加载完成时触发
                    (2) document.addEventListener('DOMContentLoaded',function(){});
                        仅当DOM加载完成，不包括样式表，图片，flash等等，速度最快（ie9以上）
                2.2 调整窗口大小事件
                    window.addEventListener('resize',function(){});
                    当浏览器被重置大小时触发
                2.3 页面重新加载事件
                    window.addEventListener('pageshow',function(){});
                    页面重新加载时触发（火狐往返缓存）
                    e.persisted 返回布尔值，判断是否是缓存中的页面触发的pageshow事件
            3. 定时器
                3.1 window.setTimeout(调用函数, 延迟的毫秒数);
                    定时器到期后执行调用函数
                    let timer1 = setTimeout(fn, 3000);
                3.2 window.clearTimeout(timeroutID);
                    停止 setTimeout 定时器
                3.3 window.setInterval(调用函数, 间隔的毫秒数);
                    反复调用一个函数
                3.4 window.clearInterval(timer);
                    停止 setInterval 定时器

                ### 时钟案例
                    var hour = document.querySelector('.hour');
                    var minute = document.querySelector('.minute');
                    var second = document.querySelector('.second');
                    function getCurrent() {
                        var date = new Date();
                        var h = date.getHours();
                        var m = date.getMinutes();
                        var s = date.getSeconds();
                        h = h < 10 ? '0' + h : h;
                        m = m < 10 ? '0' + m : m;
                        s = s < 10 ? '0' + s : s;
                        hour.innerHTML = h;
                        minute.innerHTML = m;
                        second.innerHTML = s;
                    }
                    // 先调用一次，防止刚刷新时的页面空白
                    getCurrent();
                    setInterval(function () {
                        getCurrent();
                    }, 1000);

                ### 倒计时案例
                    var hour = document.querySelector('.hour');
                    var minute = document.querySelector('.minute');
                    var second = document.querySelector('.second');           
                    function countDown(date) {
                        var date1 = new Date();
                        date = date.getTime();
                        date1 = date1.getTime();
                        var sub = date - date1;
                        sub = sub / 1000;
                        h = parseInt(sub / 60 / 60 % 24)   //   计算小时
                        m = parseInt(sub / 60 % 60);     //   计算分数
                        s = parseInt(sub % 60);            //   计算当前秒数
                        h = h < 10 ? '0' + h : h;
                        m = m < 10 ? '0' + m : m;
                        s = s < 10 ? '0' + s : s;
                        hour.innerHTML = h;
                        minute.innerHTML = m;
                        second.innerHTML = s;
                        return h + ':' + m + ':' + s;
                    }
                    const date2 = new Date('2022-03-06 18:00:00');
                    // 先调用一次函数，防止刚刷新时的1s空白
                    countDown(date2);
                    setInterval(function(){countDown(date2)}, 1000);
                
                ### 发送短信案例
                    手机号码: <input type="number"> <button>发送验证码</button>
                    let btn = document.querySelector('button');
                    btn.addEventListener('click', () => {
                        let index = 3;  // 计数器
                        btn.innerHTML = index;
                        btn.disabled = true;

                        let timer = setInterval(function () {
                            index--;
                            btn.innerHTML = index;

                            if (index == 0) {
                                btn.disabled = false;
                                btn.innerHTML = '发送验证码';
                                clearInterval(timer);
                            }
                        }, 1000);
                    });
                3.5 this 指向问题
                    (1) 全局作用域或者普通函数中 this 指向全局对象 window(定时器指向window)
                    (2) 方法调用中谁调用this指向谁
                    (3) 构造函数中this指向构造函数的实例

            4. JS 执行机制
                4.1 JS 是单线程
                    线程 Thread: 执行运算最小单位。一个理发师。
                    进程 Process: 一个应用程序(QQ、酷狗、浏览器)一个进程。一个理发店。

                    JavaScript 语言的一大特点就是单线程，也就是说，同一时间只能做一件事情。
                    单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。

                    这样所导致的问题是：如果 JS执行的时间过长，这样就会造成页面的渲染不连贯，
                    导致页面渲染加载阻塞的感觉。
                    为了解决这个问题，利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程。
                    于是，JS中出现了同步和异步
                4.2 同步和异步
                    同步交互：指发送一个请求,需要等待返回,然后才能够发送下一个请求，有个等待过程；
                    异步交互：指发送一个请求,不需要等待返回,随时可以再发送下一个请求，即不需要等待。
                
                    同步就相当于是当客户端发送请求给服务端，在等待服务端响应的请求时，客户端不做其他的事情。
                        当服务端做完了才返回到客户端。这样的话客户端需要一直等待。用户使用起来会有不友好。
                    异步就是，当客户端发送给服务端请求时，在等待服务端响应的时候，客户端可以做其他的事情，这样节约了时间，提高了效率。
                4.3 同步任务和异步任务执行过程
                    (1) 同步任务：
                        同步任务都在主线程上执行，形成一个执行栈.
                    (2) 异步任务：
                        JS的异步是通过回调函数实现的。
                        一般而言，异步任务有以下三种类型：
                        1、	普通事件，如 click, resize 等
                        2、	资源加载，如 load、error 等
                        3、	定时器，包括 setInterval, setTimeout 等.
                    异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。
                4.4 JS执行机制
                    (1) 先执行执行栈中的同步任务。
                    (2) 异步任务（回调函数）放入任务队列中。
                    (3) 一旦执行栈中的所有同步任务执行完毕，
                        系统就会按次序读取任务队列中的异步任务，
                        于是被读取的异步任务结束，结束等待状态，
                        进入执行栈(即放到执行栈的最后)，开始执行。
                    (4) 类似异步任务放入高速的服务区。
                    [注：主线程不断地进行事件循环]
            5. location 对象
                5.1 什么是 location 对象
                    window 对象提供的 location 属性，用于获取或设置窗体的 URL，并且可以解析URL
                    因为这个属性返回的是一个对象，我们将这个属性也称为 location 对象
                5.2 URL
                    IP:
                        1. 可以定位到互联网上的某个服务器(提供服务的机器)。
                        2. 四个八位二进制。点隔开。一般翻译成十进制，提高可读性。
                            0011 1111 . 1111 0000 . 0000 0000 . 1111 1111
                        百度的ip： http://202.108.22.5/  为了还记，翻译成了 www.baidu.com
                    DNS 解析: 把 ip 地址转化成 英文字母
                        1. locahost   127.0.0.1  本机(我)
                    统一资源定位符(Uniform Resource Locator)是互联网上标准资源的地址。
                    互联网上的每个文件都有一个唯一的URL ,它包含的信息指出文件的位置以及浏览器应该怎么处理它。
                    URL的一般语法格式为：
                        protocol://host[:port]/path/[?query]#fragment
                        https://www.bilibili.com/video/BV1Hb4y1k7Cb?p=4
                        组成        说明
                        protocol   通信协议常用的http,ftp,maito 等
                        host       主机（域名） www.baidu.com  localhost 
                        port       端口号可选，省略时使用方案的默认端口如http的默认端口为80
                        path       一般用来表示主机上的一个目录或文件地址,也可能是虚拟的
                        query      参数 以键值对的形式，通过&符号分隔开来
                        fragment   片段#后面内容常见于链接锚点
                5.3 location 对象的属性
                         属性                    返回值
                    localtion.href              整个URL
                    localtion.host              主机名(域名)       
                    localtion.port              端口号
                    localtion.pathname          路径
                    localtion.search            参数(?age=18)
                    localtion.hash              页面的锚点(#link) 
                5.4 location 对象的方法
                    location对象方法         返回值
                    location.assign()       网页跳转(重定向页面)。可以进行回退
                    location.replace()      替换当前页面。不记录浏览历史，不能后退
                    location.reload()       重新加载页面(相当于F5刷新)
            6. navigator 对象
                包含有关浏览器的信息
                常用属性：userAgent，返回由客户机发送服务器的 user-agent 头部的值
                if ((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) {
                    window.location.href = ""; // 移动端
                } else {
                    window.location.href = ""; // PC端
                }
            7. history 对象
                与浏览器历史记录进行交互，记录用户的浏览器的历史信息。包含用户访问过的URL
                history对象方法     作用
                back()              后退
                forward()           前进
                go(参数)            前进后退功能(正数表示前进页面数，负数表示后退页面数)

                history.back(); 
                history.go(-1);
                history.forward();
                history.go(1);

        57. PC端网页特效
            1. 元素偏移量 offset 系列
                1.1 offset 概述
                    offset 偏移量 可以动态得到元素的位置，大小等
                    (1) offsetLeft: 元素左侧的偏移量
                    (2) offsetTop:  元素上侧的偏移量
                    (3) offsetLeft、 offsetTop 是以父级为参考物。父级必须有定位，否则就是 body 为参考系。
                    (4) 没有 右侧和下侧的偏移量。
                    (5) offsetWidth  = width + border + padding
                    (6) offsetHeight = height + border + padding
                    (7) offsetWidth  可以动态地获取元素的尺寸
                    (8) offsetParent 获取有父级定位的元素节点。
                1.2 offset 和 style 区别
                                  读写   返回值    单位       样式              组成
                    offsetWidth   只读   数值型    不带单位   还可以读取类样式  width + border + padding
                    style.width   读写   字符串    带单位     行内样式         width 
                    【获取元素大小位置用 offset 合适，元素更改值用 style 合适】 
                
                ### 获取鼠标在盒子内的坐标
                    var div = document.querySelector('div');
                    div.addEventListener('mousemove', (e) => {
                        var x = e.pageX; // 鼠标在页面的坐标
                        var y = e.pageY;
                        var x1 = div.offsetLeft; // 盒子偏移量
                        var y1 = div.offsetTop;

                        var divX = e.pageX - div.offsetLeft;
                        var divY = e.pageY - div.offsetTop;

                        div.innerHTML = 'x 的坐标是' + divX + ' y 的坐标是' + divY;
                    });
            2. 元素可视区 client 系列
                client 和 offsetWidth 最大的区别就是 是否包含 border（client不包含边框）(不带单位)
                clientWidth = width + padding  
                clientHeight = height + padding
                clientTop = borderTop
                clientLeft = borderLeft

            ### 立即执行函数
                立即执行函数: 声明后，直接执行。
                语法结构1:
                    (函数的声明)(实参);
                语法结构2:
                    (函数声明(实参));     
                立即执行函数声明一个独立的作用域，里面的变量是局部变量
                    (function cook(hero) {
                        console.log(`${hero}点了油闷大虾`);
                    })('张飞');
                    (function play(game) {
                        console.log(`我喜欢玩${game}`);
                    }('吃鸡'));
            3. 元素滚动 scroll 系列
                scrollTop：返回被卷去的上侧距离
                scrollLeft：返回被卷去的左侧距离
                scrollHeight   =  height + padding  (实际的高度，包括卷去的头部)
                scrollWidth   =  width + padding  (实际的宽度，包括卷去的头部)
                
                ### 仿淘宝固定侧边栏
                    let sliderBar = document.querySelector('.slider-bar'); // 侧边栏
                    let banner = document.querySelector('.banner');
                    let main = document.querySelector('.main');
                    let goBack = document.querySelector('.goBack');
                    let distance1 = banner.offsetTop; // 距离1
                    let distanceX = sliderBar.offsetTop - banner.offsetTop; // 固定定位的距离
                    let distance2 = main.offsetTop;  // 距离2

                    // 给页面添加滚动事件
                    document.addEventListener('scroll', function () {
                        // 页面卷去的头部
                        console.log(window.pageYOffset); 
                        // 1. 滚动页面,到距离1,侧边栏变成固定定位。
                        if (window.pageYOffset >= distance1) {
                            sliderBar.style.position = 'fixed'; // 固定定位
                            sliderBar.style.top = distanceX + 'px';
                        } else {
                            sliderBar.style.position = 'absolute'; // 恢复相对定位
                            sliderBar.style.top = 300 + 'px';
                        }

                        //  2. 继续滚动页面，到距离2，显示返回顶部。
                        if (window.pageYOffset >= distance2) {
                            goBack.style.display = 'block';
                        } else {
                            goBack.style.display = 'none';
                        }
                    });

            ### mouseover 和 mouseenter区别
                mouseover      冒泡（经过子盒子也触发）
                mouseenter     不冒泡（只有经过自身盒子才触发）

            4. 动画函数封装
                4.1 动画基本原理
                    setInterval(function () {
                        let left = div.offsetLeft;
                        div.style.left = left + 50 + 'px';
                    }, 500);
                4.2 动画函数简单封装
                    // obj:移动的目标元素  target: 目标位置。
                    function animate(obj, target) {
                        let timer1 = setInterval(function () {
                            if (obj.offsetLeft > target) {
                                clearInterval(timer1);
                                return;
                            }
                            obj.style.left = obj.offsetLeft + 50 + 'px';
                        }, 500);
                    }
                    animate(div,300);
                4.3 动画函数给不同元素记录不同定时器
                    function animate(obj, target) {
                        clearInterval(obj.timer);
                        obj.timer = setInterval(function () {
                            if (obj.offsetLeft == target) {
                                clearInterval(obj.timer);
                                return;
                            }
                            obj.style.left = obj.offsetLeft + step + 'px';
                        }, 200);
                    }
                4.4 缓动动画原理
                    缓动动画公式：（目标值-现在的位置）/ 10
                     function animate(obj, target) {
                        clearInterval(obj.timer);
                        obj.timer = setInterval(function () {
                            if (obj.offsetLeft == target) {
                                clearInterval(obj.timer);
                                return;
                            }
                            // 步长 = (目标位置 - 当前位置) / 10;
                            var step = (target - obj.offsetLeft) / 10;
                            console.log(step);
                            // 步长取整
                            step = step > 0 ? Math.ceil(step) : Math.floor(step);
                            obj.style.left = obj.offsetLeft + step + 'px';
                        }, 200);
                    }
                4.5 动画函数添加回调函数
                    函数作为参数传给另一个函数
                    function move(obj, target, callBack) {
                        clearInterval(obj.timer);
                        obj.timer = setInterval(() => {
                            let left = obj.offsetLeft;
                            if (left == target) {
                                clearInterval(obj.timer);
                                // 非空判断
                                if (callBack) {
                                    callBack();
                                }
                                return;
                            }
                            let step = target - left;
                            step = step / 10;
                            step = step > 0 ? Math.ceil(step) : Math.floor(step);
                            obj.style.left = left + step + "px";
                        }, 100);
                    }
            5. 常见网页特效案例
                5.1 轮播图
                    window.addEventListener("load", function () {
                        /* 
                          轮播图功能：
                            1. 鼠标经过轮播图：左右按钮显示，离开隐藏
                            2. 点击右侧按钮一次，图片往左播放一张。左侧同理。
                            3. 图片播放同时，小圆圈跟随变化
                            4. 点击小圆圈，播放相应图片。
                            5. 鼠标经过轮播图，自动播放停止，离开继续播放
                        */
                        let arrowL = document.querySelector(".arrow-l");
                        let arrowR = document.querySelector(".arrow-r");
                        let focus = document.querySelector(".focus");

                        // 1. 鼠标接触，按钮显示
                        focus.addEventListener("mouseenter", function () {
                            arrowL.style.display = "block";
                            arrowR.style.display = "block";
                            // 10. 鼠标经过停止定时器
                            clearInterval(timer);
                            timer = null; // 清除定时器变量
                        });
                        // 1. 鼠标离开，按钮隐藏
                        focus.addEventListener("mouseleave", function () {
                            arrowL.style.display = "none";
                            arrowR.style.display = "none";
                            // 10. 鼠标离开开启定时器
                            timer = setInterval(() => {
                                // 手动调用点击事件
                                arrowR.click();
                            }, 2000);
                        });

                        // 2. 根据 lis 的数量，生成对应的小圆圈。
                        // 获取对应的 ul ol
                        let ul = focus.querySelector("ul");
                        let ol = focus.querySelector("ol");
                        let lis = ul.querySelectorAll("li");
                        let focusWidth = focus.offsetWidth;
                        // console.log(ul.children.length);
                        let num = 0;
                        let circle = 0; // 控制小圆圈的播放

                        for (let i = 0; i < ul.children.length; i++) {
                            // 创建一个小 li
                            let li = document.createElement('li');
                            // 记录当前小圆圈的索引号
                            li.setAttribute('index', i);
                            // 把小 li 插入到 ol 里面
                            ol.appendChild(li);
                            // 3. 小圆圈点击事件 创建时就绑定事件
                            li.addEventListener('click', function () {
                                for (let i = 0; i < ol.children.length; i++) {
                                    ol.children[i].className = '';
                                }
                                this.className = 'current';
                                // 4. 点击小圆圈，移动图片，移动的是ul
                                // ul 的移动距离 = 小圆圈的索引号 * 图片的宽度(往左走是负值)
                                // 点击小圆圈，获得当前索引号
                                let index = this.getAttribute('index');
                                // 点击小圆圈， 把当前索引号给 num
                                num = index;
                                circle = index;
                                // console.log(index, focusWidth);
                                animate(ul, -index * focusWidth);
                            });
                        }
                        // 把ol 的第一个li设置类名
                        ol.children[0].className = 'current';
                        // 5. 克隆第一张图片，放在 ul 后面
                        let first = lis[0].cloneNode(true);
                        ul.append(first);

                        // 6. 点击右侧按钮，图片滚动一张
                        let flag = true; // 节流阀标志
                        arrowR.addEventListener('click', function () {
                            if (flag) {
                                flag = false;
                                if (num == ul.children.length - 1) {
                                    ul.style.left = 0;
                                    num = 0;
                                }
                                num++;
                                animate(ul, -num * focusWidth, function () {
                                    flag = true;
                                });
                                // 7. 点击右侧按钮，小圆圈跟随变化
                                circle++;
                                circle = circle == ol.children.length ? 0 : circle;
                                circleChange();
                            }
                        });

                        // 8. 点击左侧按钮，图片滚动一张
                        arrowL.addEventListener('click', function () {
                            if (flag) {
                                flag = false;
                                if (num == 0) {
                                    num = ul.children.length - 1;
                                    ul.style.left = -num * focusWidth + 'px';
                                }
                                num--;
                                animate(ul, -num * focusWidth, function () {
                                    flag = true;
                                });
                                // 7. 点击右侧按钮，小圆圈跟随变化
                                circle--;
                                circle = circle < 0 ? ol.children.length - 1 : circle;
                                circleChange();
                            }
                        });

                        function circleChange() {
                            for (let i = 0; i < ol.children.length; i++) {
                                ol.children[i].className = '';
                            }
                            ol.children[circle].className = 'current';
                        }

                        // 9. 自动播放轮播图
                        let timer = setInterval(() => {
                            // 手动调用点击事件
                            arrowR.click();
                        }, 2000);
                    });
                
                5.2 节流阀
                    防止轮播图按钮连续点击造成播放过快
                    利用回调函数，添加一个变量来控制，锁住函数和解锁函数
                
                5.3 返回顶部
                    goBack.addEventListener('click', function () {
                        move(window, 0);
                    });
                    function move(obj, target, callBack) {
                        clearInterval(obj.timer);
                        obj.timer = setInterval(() => {
                            let y = obj.pageYOffset;
                            if (y == target) {
                                clearInterval(obj.timer);
                                // 非空判断
                                callBack && callBack();
                                return;
                            }
                            let step = target - y;
                            step = step / 3;
                            step = step > 0 ? Math.ceil(step) : Math.floor(step);
                            // obj.style.left = left + step + "px";
                            obj.scroll(0, y + step);
                        }, 100);
                    }

                5.4 筋斗云
                     /* 
                        需求:
                            1. 鼠标接触 li，云彩移动到当前位置。
                            2. 鼠标离开 li，云彩回到之前的位置。
                            3. 鼠标点击 li，云彩固定到点击的位置。
                    */
                    var cloud = document.querySelector('.cloud');
                    var lis = document.querySelectorAll('li');

                    // 计数器,记录云彩起始位置
                    var current = 0;
                    for (var i = 0; i < lis.length; i++) {
                        // 鼠标接触 li
                        lis[i].addEventListener('mouseenter', function () {
                            console.log('mouseenter');
                            animate(cloud, this.offsetLeft);
                        });
                        // 鼠标离开 li
                        lis[i].addEventListener('mouseleave', function () {
                            console.log('mouseleave');
                            animate(cloud, current);
                        });
                        // 鼠标点击 li
                        lis[i].addEventListener('click', function () {
                            console.log('click');
                            current = this.offsetLeft;
                        });
                    }

        58. 移动端网页特效
            1. 触屏事件
                1.1 触摸事件
                    (1) touchstart 手指开始触摸屏幕的事件
                    (2) touchmove  手指在屏幕上移动的事件
                    (3) touchend   手指离开屏幕
                1.2 触摸事件对象（TouchEvent）
                    移动端的事件对象
                    e:                事件对象
                    e.type            事件类型
                    e.touches         触摸屏幕的触点列表
                    e.targetTouches   触摸元素的触点列表
                    e.changedTouches  手指状态发生了改变的列表(触发事件的触点列表)
                1.3 移动端拖动元素
